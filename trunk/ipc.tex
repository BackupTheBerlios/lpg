%%\input{epsf.tex}
%\usepackage{graphics}

\chapter{\label{scott}Komunikacja miêdzyprocesowa w Linuksie}
\author{B. Scott Burkett, {\tt scottb@intnet.net}}
\date{v1.0, 29 March 1995}
\abstract{Szczegó³owy przegl±d IPC ( komunikacji miêdzyprocesowej ) 
zaimplementowanej w Linuksie.}

\section{Wstêp}
IPC w Linuksie dostarcza metod komunikacji miêdzy ró¿nymi procesami. Istnieje
kilka metod IPC dostêpnych w Linuksie:
\begin{itemize}
\item Jednokierunkowe potoki z Unixa
\item FIFO ( nazwane potoki )
\item kolejki wiadomo¶ci stylu SYSV
\item semafory stylu SYSV
\item segmenty pamiêci dzielonej stylu SYSV
\item Gniazda ( sockets ) sieciowe ( styl Berkeley ) ( nie omawiane )
\item Dwukierunkowe potoki ( STREAMS ) ( nie omawiane )
\end{itemize}

Narzêdzia te, u¿ywane efektywnie, dostarczaj± porz±dnych podstaw do tworzenia
aplikacji typu klient/serwer w Uniksie ( w³±czaj±c Linuksa ).

\section{Jednokierunkowe potoki z Unixa}


\subsection{Podstawy}

Najpro¶ciej, {\em potok\/} jest metod± przekierowywania {\em standardowego wyj¶cia\/} 
jednego procesu na {\em standardowe wej¶cie\/} innego.  Potoki s± najstarszym
narzêdziem IPC, istniej± od najwcze¶niejszych wersji systemu operacyjnego UNIX. 
S± szeroko u¿ywane, nawet w linii poleceñ pow³oki.

\begin{tscreen}
\begin{verbatim}
        ls | sort | lp
\end{verbatim}


\end{tscreen}

Powy¿szy przyk³ad pokazuje zbiór potoków; przetworzenie wyj¶cia ls na
wej¶cie programu sort, a pó¿niejsze u¿ycie wyj¶cia sort jako wej¶cie lp.
Dane przemieszczaj± siê w jednokierunkowym potoku, wizualnie od lewej do prawej.

Aczkolwiek z zami³owaniem u¿ywamy potoków w ró¿nych skryptach, rzadko zadajemy 
sobie pytanie co siê dzieje na poziomie j±dra.

Kiedy proces tworzy potok, j±dro tworzy dwa deskryptory na jego u¿ytek.
Jeden umo¿liwia zapis do potoku, drugi czytanie z niego. Na tym poziomie, 
potoki s± ma³o u¿yteczne, gdy¿ tylko proces tworz±cy potok mo¿e z niego czytaæ.
Oto reprezentacja procesu i j±dra po utworzeniu potoku:

\begin {center}
\includegraphics{pipe1.epsi}
%\input {pipe1}
\end   {center}

Z powy¿szego rysunku ³atwo mo¿na dostrzec jak deskryptory s± po³±czone nawzajem.
Je¿eli proces wysy³a dane poprzez potok ( fd0 ), mo¿e je otrzymaæ z fd1.
Jest to bardziej z³o¿ony proces, ni¿ widaæ na rysunku. Gdy proces tworzy
potok, a pó¿niej podczas przekazywania danych informacje przep³ywaj± przez j±dro.
Pod Linuxem, potoki s± obecnie prezentowane wewnêtrznie jako prawid³owe i-wêz³y
( inodes ). Oczywi¶cie taki i-wêze³ przebywa wewn±trz j±dra, nie na jakim¶ 
fizycznym systemie plików. Takie podej¶cie otwiera nam ³adn±, porêczn± furtkê We/Wy,
o czym przekonamy siê pó¿niej.

Na razie potoki s± daleko bezurzyteczne. Po co zadawaæ sobie trud tworzenia
potoku aby porozmawiaæ ze sob±? Najczê¶ciej proces tworz±cy potok tworzy
( forkuje ;) proces potomny. Proces potomny odziedzicza po rodzicu wszelkie otwarte
deskryptory plików, mamy teraz podstawy aby komunikowaæ siê miêdzy procesami.
Oto uaktualniony diagram:

\begin {center}
\includegraphics{pipe2.epsi}
%\input {pipe2}
\end   {center}

Widzimy, i¿ oba procesy maj± dostêp do deskryptorów plików, które tworz± potok.
Na tym poziomie musimy podj±æ krytyczn± decyzjê: w jakim kierunku bêd± przesy³ane
dane? Po wybraniu kierunku procesy zamykaj± koñcówkê potoku, z której nie bêd±
korzystaæ. Przyjmijmy, ¿e potomek przeprowadza jak±¶ akcjê i wywsy³a wynik poprzez
potok do rodzica. Oto nasz nowy rysunek:

\begin {center}
\includegraphics{pipe3.epsi}
%\input {pipe3}
\end   {center}

Konstrukcja potoku jest gotowa! Jedyne co musimy teraz zrobiæ to u¿yæ
potoku. Aby tego dokonaæ bezpo¶rednio mo¿emy u¿ywaæ tych samych wywo³añ systemowych,
które istniej± do niskopoziomowego dostêpu We/Wy do plików ( pamiêtaj, ¿e potoki
obecnie prezentowane s± jako normalne i-wêz³y )

Aby wys³aæ dane do potoku u¿ywamy wywo³ania systemowego write(), natomiast aby
odczytaæ dane musimy pos³u¿yæ siê wywo³aniem read(). Pamiêtaj, ¿e niskopoziomowe
We/Wy do pliku dzia³a z jego deskryptorem! Jednocze¶nie musisz sobie zdawaæ 
sprawê, ¿e niektóre wywo³ania systemowe, takie jak lseek(), nie dzia³aj± z deskryptorami
potoków.




\subsection{Tworzenie potoków w C}

Tworzenie potoków wraz z C mo¿e byæ troszeczkê trudniejsze ni¿ to wynika z naszych
do¶wiadczeñ z pow³oki. Aby utworzyæ prosty potok w C musimy pos³u¿yæ siê wywo³aniem
systemowym pipe(). Podaje siê jeden argument, który jest tablic± dwóch liczb 
ca³kowitych, je¿eli nasze wywo³anie powiod³o siê macierz zawiera dwa deskryptory
plików, które urzywamy do operacji na potoku. Najczê¶ciej po takiej operacji
proces tworzy swojego potomka, który dziedziczy wszystkie otwarte deskryptory
plików.


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
  WYWO£ANIE SYSTEMOWE: pipe();                                                          

  PROTOTYP: int pipe( int fd[2] );                                             
    ZWRACA: 0 - sukces                                                       
             -1 b³±d: errno = EMFILE ( brak wolnych deskryptorów )                  
                                  EMFILE ( tablica systemu plików jest pe³na )
                                  EFAULT ( tablica fd jest nieprawid³owa )                

  UWAGI: fd[0] s³u¿y do czytania, fd[1] s³u¿y do pisania               
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


Pierwsza liczba ca³kowita w macierzy ( element 0 ) jest ustawiana i otwierana w
celu odczytu, natomiast drugi element s³u¿y do pisania. Unaoczniaj±c, wyj¶cie
fd$1$ staje siê wej¶ciem dla fd$0$. Oczywi¶cie wszelkie dane przesy³ane przez
potok s± przesy³ane przez j±dro.

\begin{verbatim}
        #include <stdio.h>
        #include <unistd.h>
        #include <sys/types.h>

        main()
        {
                int     fd[2];
                
                pipe(fd);
                .
                .
        }
\end{verbatim}



Pamiêtaj, ¿e nazwa macierzy w C {\em wskazuje\/} pierwszy element. Czyli {\tt fd}
jest wska¼nikiem do {\tt \&fd[0]}. Po stworzeniu potoku forkujemy naszego potomka.

\begin{verbatim}
        #include <stdio.h>
        #include <unistd.h>
        #include <sys/types.h>

        main()
        {
                int     fd[2];
                pid_t   childpid;

                pipe(fd);
        
                if((childpid = fork()) == -1)
                {
                        perror("fork");
                        exit(1);
                }
                .
                .
        }
\end{verbatim}


Je¿eli rodzic chce otrzymywaæ dane od procesu potomnego powinien zamkn±æ fd$1$,
potomek powinien to uczyniæ z fd$0$. Je¿eli ma byæ odwrotnie, rodzic zamyka
fd$0$, a potomek zamyka fd$1$. Poniewa¿ deskryptory s± wspólne dla potomka i rodzica
musimy pamiêtaæ aby zamkn±æ koñcówkê, której nie bêdziemy u¿ywaæ, gdy¿ je¿eli
tego nie zrobimy nigdy nie otrzymamy EOF.


\begin{verbatim}
        #include <stdio.h>
        #include <unistd.h>
        #include <sys/types.h>

        main()
        {
                int     fd[2];
                pid_t   childpid;

                pipe(fd);
        
                if((childpid = fork()) == -1)
                {
                        perror("fork");
                        exit(1);
                }

                if(childpid == 0)
                {
                        /* Potomek zamyka koñcówkê wej¶ciow± potoku */
                        close(fd[0]);
                }
                else
                {
                        /* Rodzic zamyka koñcówkê wyj¶ciow± potoku */
                        close(fd[1]);
                }
                .
                .
        }
\end{verbatim}


Po ustaleniu kierunku przep³ywu mo¿emy u¿ywaæ deskryptorów jako zwyk³e
deskryptory plików.

\begin{verbatim}

/*****************************************************************************
 Zaczerpniête z "Linux Programmer's Guide - Rozdzia³ 6"
 (C)opyright 1994-1995, Scott Burkett
 ***************************************************************************** 
 MODU£: pipe.c
 *****************************************************************************/

#include <stdio.h>
#include <unistd.h>
#include <sys/types.h>

int main(void)
{
        int     fd[2], nbytes;
        pid_t   childpid;
        char    string[] = "Pozdrowienia przesy³a Zdzisiek z rodzin±!\n";
        char    readbuffer[80];

        pipe(fd);
        
        if((childpid = fork()) == -1)
        {
                perror("fork");
                exit(1);
        }

        if(childpid == 0)
        {
                /* Potomek zamyka koñcówkê wej¶ciow± */
                close(fd[0]);

                /* Przesy³amy "string" poprzez koñcówke wyj¶ciow± potoku */
		write(fd[1], string, strlen(string));
                exit(0);
        }
        else
        {
                /* Rodzic zamyka koñcówkê wyj¶ciow± */
                close(fd[1]);

                /* oraz wczytuje dane z potoku */
                nbytes = read(fd[0], readbuffer, sizeof(readbuffer));
                printf("Otrzymany ³añcuch: %s", readbuffer);
        }
        
        return(0);
}
\end{verbatim}


Czêsto deskryptory w procesie potomnym s± duplikowane na standardowe wej¶cie lub
wyj¶cie, nastêpnie proces potomny mo¿e wykonaæ - exec() inny program, który dziedziczy
standardowe strumienie. Przyj¿yjmy siê wywo³aniu dup():

\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
  WYWO£ANIE SYSTEMOWE: dup();                                                           

  PROTOTYP: int dup( int staryfd );                                              
    ZWRACA: je¿eli siê powiod³o otrzymujemy nowy deskryptor                                          
             -1 - b³±d: errno = EBADF ( staryfd nie jest prawid³owym deskryptorem )       
                                EBADF ( nowyfd jest poza zasiêgiem )
				EMFILE ( za du¿o deskryptorów dla procesu ) 

  UWAGI: stary deskryptor nie jest zamykany!  Mo¿na ich u¿ywaæ zamiennie.    
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


Pomimo tego, i¿ stary deskryptor mo¿e byæ u¿ywany zamiennie z nowowo utworzonym
najczê¶ciej najpierw zamyka siê standardowe strumienie. Wywo³anie systemowe
dup() u¿ywa pierwszego wolnego deskryptora.
new one.

Rozwa¿:

\begin{verbatim}
        .
        .
        childpid = fork();
        
        if(childpid == 0)
        {
                /* Zamykamy standardowe wej¶cie potomka */
                close(0);
                
                /* Duplikujemy wej¶cie potoku jako stdin */
                dup(fd[0]);
                execlp("sort", "sort", NULL);
                .
        }
\end{verbatim}

Zamkneli¶my deskryptor pliku 0 ( stdin ), poprzez wywo³anie dup() zduplikowali¶my
deskryptor potoku (fd$0$) na stardardowe wej¶cie potomka. Po tym wywo³ali¶my
execlp() aby zamieniæ segment tekstowy potomka ( kod ) programem sort.
Dziêki temu, ¿e programy uruchomione poprzez exec dziedzicz± standardowe
strumienie programów wywo³uj±cych je, sort dziedziczy wej¶ciow± czê¶æ potoku
jako swoje standardowe wej¶cie! Teraz wszystko co wysys³a rodzic do potoku 
kierowane jest do programu sort.

Istnieje inne wywo³anie systemowe - dup2(), którego mo¿na równie¿ u¿ywaæ.
To wywo³anie oryginalnie powsta³o w 7 Wersji Unixa i zosta³o przeniesione do
BSD, obecnie wymagane jest przez standard POSIX.


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
  WYWO£ANIE SYSTEMOWE: dup2();                                                          

  PROTOTYP: int dup2( int staryfd, int nowyfd );                                  
    ZWRACA: nowy deskryptor je¿eli wszystko ok                                          
             -1 - b³±d:errno = EBADF ( staryfd nie jest prawid³owym deskryptorem )       
                               EBADF ( nowyfd poza zasiêgiem )                 
                               EMFILE ( zbyt du¿o deskryptorów dla procesu ) 

  UWAGI: dup2() zamyka stary deskryptor!                              
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


Dziêki temu wywo³aniu mamy duplikacjê deskryptora i zamkniêcie poprzedniego
w jednym. Dodatkowo, mamy zapewnione atomowe(atomic) dzia³anie, które oznacza,
¿e nie zostanie ono przerwane przez nadchodz±cy sygna³. Ca³a operacja
zostanie wykonana z wy³±czeniem przesy³ania sygna³ów przez j±dro.
U¿ywaj±c oryginalnego dup() programi¶ci musieli zamkn±æ deskryptor przed u¿yciem
wywo³ania. Przez co tworzy³ siê pewien s³aby punkt pomiêdzy tymi wywo³aniami - 
je¿eli sygna³ dotar³ pomiêdzy wywo³aniami close() i dup() duplikacja deskryptorów
mog³a zawie¶æ. Dup2() rozwi±zuje ten problem.

Rozwa¿:

\begin{verbatim}
        .
        .
        childpid = fork();
        
        if(childpid == 0)
        {
                /* Zamknij stdin, duplikuj wej¶ciow± stronê potoku na stdin */
                dup2(0, fd[0]);
                execlp("sort", "sort", NULL);
                .
                .
        }
\end{verbatim}


\subsection{Potoki - prosta metoda!}

Je¿eli powy¿sze przyk³ady wydaj± ci siê zakrêcon± metod± tworzenia potoków, mo¿na
zrobiæ to w inny sposób.


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
  FUNKCJA Z BIBLIOTEKI: popen();                                                    

  PROTOTYP: FILE *popen ( char *komenda, char *typ);                          
    ZWRACA: nowy strumieñ do pliku je¿eli sukces
             NULL je¿eli fork() lub pipe() zawiod³o                         

  UWAGI: tworzy potok oraz przeprowadza fork/exec u¿ywaj±c "komendy"
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}

Ta standardowa funckja biblioteki tworzy potok wywo³uj±c wewnêtrznie pipe().
Po tym forkuje proces potomny, uruchamia pow³okê Bourne'a oraz uruchamia
argument "komenda" korzystaj±c z pow³oki. Kierunek przep³ywu danych
okre¶lany jest przez argument "typ", który mo¿e przybieraæ warto¶ci
"r" ( odczyt ) lub "w" ( zapis ). Nie mo¿na ich u¿yæ jednocze¶nie. 
Je¿eli ciê podkusi i podasz "rw" pod Linuxem potok zostanie otwarty w trybie
wskazanym przez pierwsz± literê, czyli w tym wypadku w trybie odczytu.

Przez to, ¿e ta funkcja odwala za ciebie wiêkszo¶æ roboty tracisz kontrolê, 
któr± mia³e¶ pos³uguj±c siê pipe() i samemu forkuj±c. Z drugiej strony 
dziêki temu, i¿ pow³oka Bourne'a jest u¿ywana bezpo¶rednio mo¿esz korzystaæ z 
dobrodziejstwa masek oraz rozwijania metaznaków.

Potoki otwierane za pomoc± popen() musz± zostaæ zamkniête funkcj± pclose().
Prawdopodobnie ju¿ spostrzeg³e¶ podobieñstwo popen/pclose do standardowych
funkcji strumieniowego We/Wy do plików - fopen() i fclose().

\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
  FUNKCJA Z BIBLIOTEKI: pclose();                                                   

  PROTOTYP: int pclose( FILE *stream );                                        
    ZWRACA: status wyj¶ciowy wywo³ania wait4()
             -1 je¿eli "stream" jest nieprawid³owy lub zawiod³o wait4()

  UWAGI: czeka na zakoñczenie operacji na potoku, pó¿niej zamyka potok
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


Funkcja pclose() uruchamia wait4() dla procesu utworzonego przez popen().
Po powrocie z wait4() niszczy potok oraz strumieñ do pliku.

Rozwa¿ poni¿szy przyk³ad, który otwiera potok dla komendy sort, wykorzystuj±c
j± sortuje tablicê ³añcuchów:

\begin{verbatim}

/*****************************************************************************
 Zaczerpniêto z "Linux Programmer's Guide - Rozdzia³ 6"
 (C)opyright 1994-1995, Scott Burkett
 ***************************************************************************** 
 MODU£: popen1.c
 *****************************************************************************/
  
#include <stdio.h>

#define MAXSTRS 5

int main(void)
{
        int  cntr;
        FILE *pipe_fp;
        char *strings[MAXSTRS] = { "echo", "bravo", "alpha",
                                  "charlie", "delta"};

        /* Tworzymy jednokierunkowy potok za pomoc± popen() */
        if (( pipe_fp = popen("sort", "w")) == NULL)
        {
                perror("popen");
                exit(1);
        }

        /* Pêtla przetwarzaj±ca */
        for(cntr=0; cntr<MAXSTRS; cntr++) {
                fputs(strings[cntr], pipe_fp);
                fputc('\n', pipe_fp);
        }

        /* Zamykamy potok */
        pclose(pipe_fp);
        
        return(0);
}
\end{verbatim}


Dziêki temu, i¿ {\tt popen()} korzysta z pow³oki wszystkie rozwiniêcia znaków i
metaznaków s± dostêpne! Mo¿emy równie¿ korzystaæ z bardziej zaawansowanych 
technik jak przekierowywanie, u¿ywanie potoków. Popatrz na poni¿sze przyk³ady:

\begin{verbatim}
        popen("ls ~scottb", "r");
        popen("sort > /tmp/foo", "w");
        popen("sort | uniq | more", "w");
\end{verbatim}


Jako nastêpny przyk³ad programik, który otwiera dwa potoki ( jeden do ls,
drugi do sort ):

\begin{verbatim}

/*****************************************************************************
 Zaczerpniêto z "Linux Programmer's Guide - Rozdzia³ 6"
 (C)opyright 1994-1995, Scott Burkett
 ***************************************************************************** 
 MODU£: popen2.c
 *****************************************************************************/

#include <stdio.h>

int main(void)
{
        FILE *pipein_fp, *pipeout_fp;
        char readbuf[80];

        /* Tworzymy jednokierunkowy potok za pomoc± popen() */
        if (( pipein_fp = popen("ls", "r")) == NULL)
        {
                perror("popen");
                exit(1);
        }

        /* Tworzymy jednokierunkowy potok za pomoc± popen() */
        if (( pipeout_fp = popen("sort", "w")) == NULL)
        {
                perror("popen");
                exit(1);
        }

        /* Przetwarzanie */
        while(fgets(readbuf, 80, pipein_fp))
                fputs(readbuf, pipeout_fp);

        /* Zamkniêcie potoków */
        pclose(pipein_fp);
        pclose(pipeout_fp);

        return(0);
}
\end{verbatim}

Oto nasz koñcowy przyk³ad u¿ycie popen(). Tworzymy program, który tworzy
potok miêdzy podan± komend± i plikiem:

\begin{verbatim}

/*****************************************************************************
 Zaczerpniêto z "Linux Programmer's Guide - Rozdzia³ 6"
 (C)opyright 1994-1995, Scott Burkett
 ***************************************************************************** 
 MODU£: popen3.c
 *****************************************************************************/

#include <stdio.h>

int main(int argc, char *argv[])
{
        FILE *pipe_fp, *infile;
        char readbuf[80];

        if( argc != 3) {
                fprintf(stderr, "U¯YCIE:  popen3 [komenda] [plik]\n");       
                exit(1);
        }

        /* Otwieramy plik wej¶ciowy */
        if (( infile = fopen(argv[2], "rt")) == NULL)
        {
                perror("fopen");
                exit(1);        
        }

        /* Tworzymy jednokierunkowy potok za pomoc± popen() */
        if (( pipe_fp = popen(argv[1], "w")) == NULL)
        {
                perror("popen");
                exit(1);
        }

        do { 
                fgets(readbuf, 80, infile);
                if(feof(infile)) break;

                fputs(readbuf, pipe_fp);
        } while(!feof(infile));

        fclose(infile); 
        pclose(pipe_fp);

        return(0);
}
\end{verbatim}

Wyprubuj program:
\begin{verbatim}
        popen3 sort popen3.c
        popen3 cat popen3.c
        popen3 more popen3.c
        popen3 cat popen3.c | grep main
\end{verbatim}







\subsection{Atomowe operacje na potokach}


Aby operacja mog³a zostaæ uznana za 'atomow±', musi spe³niæ jeden warunek - nic
nie mo¿e jej przerwaæ. Standard POSIX ustala w /usr/include/posix1\_lim.h, i¿ 
maxymalny rozmiar bufora dla operacji atomowej na potoku to:

\begin{verbatim}
        #define _POSIX_PIPE_BUF         512
\end{verbatim}

Czyli do 512 bajtów mo¿e zostaæ zapisanych lub odczytanych atomowo z potoku.
Je¿eli warto¶æ ta zostanie przekroczona operacja zostanie podzielona i nie
bêdzie atomowa. Pod Linuxem limit dla operacji atomowej zosta³ zdefiniowany
w 'linux/limits.h' na:

\begin{verbatim}
        #define PIPE_BUF        4096
\end{verbatim}

Jak widzisz Linux ³agodzi wymagania POSIX, mogê dodaæ, i¿ ca³kiem rozs±dnie.
Atomowo¶æ operacji na potoku jest wa¿na gdy wiêcej ni¿ jeden proces jest
wykonywany ( FIFO ). Dla przyk³adu: je¿eli ograniczenie zosta³o przekroczone, a
wiêcej ni¿ jeden proces zapisuj± do potoku, dane zostan± przeplecione lub
nadpisane (chunked). Innymi s³owy, proces mo¿e zapisaæ dane do potoku, pomiêdzy
zapisami czynionymi przez inny.


\subsection{Uwagi na temat jednokierunkowych potoków:}



\begin{itemize}
\item Dwukierunkowy potok mo¿e zostaæ stworzony poprzez otwarcie dwóch
potoków oraz odpowiednie przemianowanie deskryptorów w potomku.
\item Wywo³anie pipe() musi zostaæ uruchomione PRZED wywo³aniem fork(), w innym
wypadku potomek nie odziedziczy deskryptorów! ( dotyczy równie¿ popen() ).
\item U¿ywaj±c jednokierunkowych potoków nale¿y pamiêtaæ, i¿ wszystkie procesy
przy³±czone do potoku musz± mieæ wspólnego przodka. Dzieje siê tak dlatego, ¿e
j±dro nie zezwala na adresacjê pamiêci, w której znajduje siê potok, je¿eli nie
jest siê potomkiem twórcy potoku. W przypadku nazwanych potoków nie zachodzi to
ograniczenie.
\end{itemize}





\section{Nazwane potoki ( FIFO - First In First Out; Kto pierwszy ten lepszy )}




\subsection{Podstawy}

Nazwany potok pracuje podobnie jak normalny ale znacz±co ró¿ni siê.
\begin{itemize}
\item Nazwane potoki istniej± w systemie plików jako plik urz±dzenia.
\item Procesy ró¿nych rodziców mog± dzieliæ dane poprzez nazwany potok.
\item Po skoñczeniu wszystkich operacji nazwany potok pozastaje w systemie plików
w celu pó¿niejszego u¿ycia.
\end{itemize}





\subsection{Tworzenie FIFO}


Istnieje kilka sposobów aby utworzyæ nazwany potok. Dwie pierwsze mog± zostaæ
wykonane bezpo¶rednio z pow³oki.

\begin{verbatim}
        mknod MOJEFIFO p
        mkfifo a=rw MOJEFIFO
\end{verbatim}


Powy¿sze dwie komendy wykonuj± to samo zadanie, z jednym wyj±tkiem. Komenda
mkfifo umo¿liwia zmianê atrybutów utworzonego FIFO. Natomiast po u¿yciu mknod
bêdziemy musieli w tym celu uruchomiæ chmod.

FIFO mo¿e byæ szybko zidentyfikowane poprzez literkê 'p' w listingu:

\begin{verbatim}
        $ ls -l MYFIFO
        prw-r--r--   1 root     root            0 Dec 14 22:15 MYFIFO|
\end{verbatim}


Zauwa¿ równie¿ znak potoku przy nazwie.

Aby utworzyæ FIFO za pomoc± C musimy pos³u¿yæ siê wywo³aniem systemowym mknod():

\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
  FUNKCJA Z BIBLIOTEKI: mknod();                                                    

  PROTOTYP: int mknod( char *¶cie¿ka, mode_t tryb, dev_t dev);                
    ZWRACA: 0 - sukces,                                                      
             -1 - b³±d: errno = EFAULT ( nieprawid³owa ¶cie¿ka )                     
                                  EACCES ( niedozwolona operacja )                    
                                  ENAMETOOLONG ( ¶cie¿ka za d³uga )              
                                  ENOENT ( nieprawid³owa ¶cie¿ka )                     
                                  ENOTDIR ( nieprawid³owa ¶cie¿ka )                    
                                  ( zerknij do podrêcznika mknod po wiêcej )           

  UWAGI: Tworzy wêze³ w systemie plików ( plik, plik urz±dzenia, FIFO )                 
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


Szczegó³owe omówienie mknod() pozostawiê podrêcznikowi, natomiast my zajmiemy siê
prostym przyk³adem tworzenia FIFO w C:

\begin{verbatim}
                mknod("/tmp/MOJEFIFO", S_IFIFO|0666, 0);
\end{verbatim}


W tym wypadku zostanie utworzony jako FIFO plik '/tmp/MOJEFIFO'. ¯±danymi prawami
dostêpu s± '0666', jednak¿e zale¿± one równie¿ od ustawienia umask w nastêpuj±cy
sposób:

\begin{verbatim}
                koñcowe_prawa = ¿±dane_prawa & ~oryginalny_umask
\end{verbatim}

Trikiem na obej¶cie tego jest u¿ycie umask() w celu tymczasowego ustawienia
warto¶ci umask:

\begin{verbatim}
                umask(0);
                mknod("/tmp/MOJEFIFO", S_IFIFO|0666, 0);
\end{verbatim}

Trzeci argument mknod() jest ignorowany, chyba ¿e tworzymy plik urz±dzenia. W takim
wypadku s³u¿y on do ustawienia g³ównego i podrzêdnego numeru pliku urz±dzenia.



\subsection{Operowanie FIFO}

Operacje We/Wy na FIFO s± w³a¶ciwie takie same jak dla normalnych potoków, z
jednym wyj±tkiem - musimy u¿yæ wywo³ania lub funkcji 'open' w celu fizycznego 
otwarcia kana³u do potoku. U¿ywaj±c potoków nie musieli¶my tego robiæ, gdy¿
potok rezydowa³ w j±drze a nie w systemie plików. W naszych przyk³adach bêdziemy
traktowaæ potoki tak jak strumienie - otwieramy je za pomoc± fopen(), a zamykamy
za pomoc± fclose().

Rozwa¿ ten prosty proces serwera:


\begin{verbatim}
/*****************************************************************************
 Zaczerpniêto z "Linux Programmer's Guide - Rozdzia³ 6"
 (C)opyright 1994-1995, Scott Burkett
 ***************************************************************************** 
 MODU£: fifoserver.c
 *****************************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <sys/stat.h>
#include <unistd.h>

#include <linux/stat.h>

#define FIFO_FILE       "MOJEFIFO"

int main(void)
{
        FILE *fp;
        char readbuf[80];

        /* Tworzymy FIFO je¿eli nie istnieje */
        umask(0);
        mknod(FIFO_FILE, S_IFIFO|0666, 0);

        while(1)
        {
                fp = fopen(FIFO_FILE, "r");
                fgets(readbuf, 80, fp);
                printf("Otrzymany ³añcuch: %s\n", readbuf);
                fclose(fp);
        }

        return(0);
}
\end{verbatim}


Jako¿e FIFO domy¶lnie blokuje program, uruchom go w tle:

\begin{verbatim}
        $ fifoserver&
\end{verbatim}

Blokowanie akcji przez FIFO omówimy za chwilê. Na razie, rozwa¿ nastêpuj±cy
przyk³ad prostego klienta:

\begin{verbatim}

/*****************************************************************************
 Zaczerpniêto z "Linux Programmer's Guide - Rozdzia³ 6"
 (C)opyright 1994-1995, Scott Burkett
 ***************************************************************************** 
 MODU£: fifoclient.c
 *****************************************************************************/

#include <stdio.h>
#include <stdlib.h>

#define FIFO_FILE       "MOJEFIFO"

int main(int argc, char *argv[])
{
        FILE *fp;

        if ( argc != 2 ) {
                printf("U¯YCIE: fifoclient [³añcuch]\n");
                exit(1);
        }

        if((fp = fopen(FIFO_FILE, "w")) == NULL) {
                perror("fopen");
                exit(1);
        }

        fputs(argv[1], fp);

        fclose(fp);
        return(0);
}
\end{verbatim}







\subsection{Blokowanie akcji przez FIFO}

Normalnie, FIFO blokuje wykonywanie programu. Dla przyk³adu je¿eli otworzymy FIFO
do czytania wykonywanie programu zostanie zatrzymane do czasu gdy inny proces otworzy
FIFO do pisania. Oczywi¶cie dzia³a to równie¿ w dug± stronê. Je¿eli nie podoba nam siê
takie dzia³anie musimy przekazaæ znacznik O\_NONBLOCK wywo³aniu open().

W przypadku naszego prostego serwera, który czeka w tle na klienta mogliby¶my
uruchomiæ go w pierwszym planie, prze³±czyæ siê na inn± konsolê, odpaliæ klienta, 
i prze³±czaj±c siê patrzeæ co siê dzieje.



\subsection{Ohydny sygna³ SIGPIPE}

Nale¿y pamiêtaæ, i¿ ka¿dy potok musi posiadaæ proces czytaj±cy i zapisuj±cy. 
Je¿eli jaki¶ proces próbuje przes³aæ dane przez potoku nie posiadaj±cy koñcówki 
czytaj±cej j±dro prze¶le sygna³ SIGPIPE. Jest to konieczne gdy wiêcej ni¿ 
dwa procesy korzystaj± z potoku. 




\section{IPC w Systemie V}






\subsection{Podstawy}

W Systemie V AT\&T wprowadzi³ trzy nowe formy IPC ( kolejki wiadomo¶ci,
 semafory oraz pamiêæ dzielon± ). Podczas gdy komitet POSIX pracowa³ nad
standaryzacj± tych us³ug wiêkszo¶æ implementacji wspiera³a je. Dodatkowo, BSD
u¿ywa gniazd (sockets) jako podstawê IPC czê¶ciej ni¿ elementy z Systemu V.
Linux mo¿e obs³ugiwaæ obie formy IPC ( BSD lub System V ), jednak¿e gniazda
omówimy w pó¿niejszym rozdziale.
 
Implementacja IPC Systemu V dla Linuksa zosta³a stworzona przez {\em Krishna Balasubramanian\/},
{\tt balasub@cis.ohio-state.edu}.


\subsubsection{Identyfikatory IPC}


Ka¿dy {\em obiekt\/} IPC posiada unikalny identyfikator. Kiedy mówimy 'obiekt IPC'
mamy na my¶li pojedyñcz± kolejkê wiadomo¶ci, zestaw semaforów lub segment pamiêci
dzielonel. Identyfikator u¿ywany jest przez j±dro w celu identyfikacji obiektu IPC.
Dla przyk³adu, aby u¿yæ segmentu pamiêci dzielonej musimy znaæ jedynie unikaln±
warto¶æ ID, która zosta³a przyporz±dkowana temu segmentowi.

Unikalno¶æ identyfikatora uzale¿niona jest od {\em typu\/} obiektu. Aby to
zilustrowaæ za³u¿my, i¿ pos³ugujemy siê warto¶ci± '12345'. Podczas gdy nie
mog± istnieæ dwie kolejki wiadomo¶ci o tym samym numerze, istnieje mo¿liwo¶æ
utworzenia kolejki i, powiedzmy, segmentu pamiêci dzielonej o tym samym numerze.


\subsubsection{Klucze IPC}

Aby otrzymaæ unikalne ID musimy pos³u¿yæ siê {\em kluczem\/}. Klucz musi
zostaæ uzgodniony przez procesy klienta i serwera. Jest to pierwszy krok przy
tworzeniu aplikacji klient/serwer.

{\em Kiedy u¿ywasz telefonu: aby dodzwoniæ siê do kogo¶ musisz znaæ jego numer.
Dodatkowo, operator telefoniczny musi wiedzieæ w jaki sposób po³±czyæ ciebie.
Kiedy ta osoba odbiera tworzone jest po³±czenie.\/}

W wypadku IPC Systemu V 'telefon' odpowiada bezpo¶rednio typowi u¿ywanego obiektu.
'Operator telefoniczny', lub metoda po³±czenia mo¿e byæ przyporz±dkowana kluczowi IPC.

Klucz mo¿e byæ za ka¿dym razem ten sam, zakodowany w aplikacji. Jednak ma to swoj±
wadê - istnieje mo¿liwo¶æ, i¿ jest on ju¿ u¿ywany. Czêsto korzysta siê z funkcji
ftok() w celu utworzenia warto¶ci klucza, który ma byæ u¿yty przez klienta i serwer.

\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
  FUNKCJA Z BIBLIOTEKI: ftok();

  PROTOTYP: key_t ftok ( char *¶cie¿ka, char proj );
    ZWRACA: now± warto¶æ klucza IPC je¿eli sukces
             -1 - b³±d, warto¶æ errno odpowiada wywo³aniu stat()
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}

Zwracan± warto¶ci± jest klucz utworzony na podstawie kombinacji numeru i-wêz³a
i podrzêdnego numeru urz±dzenia z pliku podanego w pierwszym argumencie wraz z
identyfikatorem projektu podanym jako drugi argument. To nie gwarantuje
unikalno¶ci, jednak aplikacja mo¿e sprawdziæ czy nie zachodzi kolizja i powtórzyæ
generacjê klucza.



\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
        key_t   mójklucz;
        mójklucz = ftok("/tmp/mojaapp", 'a');
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}

W powy¿szym przyk³adzie klucz tworzony jest z kombinacji katalogu {\tt /tmp/mojaapp} 
z liter± {\tt 'a'}. Inn± mo¿liwo¶ci± jest u¿ycie bierz±cego katalogu:

\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
        key_t   mójklucz;
        mykey = ftok(".", 'a');
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}

Algorytm generacji klucza jest ca³kowicie zale¿ny od programisty. Do póty, do póki
nie dopuszcza siê do przypadku wy¶cigu, powieszenia (deadlocks) procesu ka¿da metoda
jest dobra. W celu demonstracyjnym u¿ywamy ftok() zak³adamy, ¿e ka¿dy klient
posiada unikalny katalog 'domowy', a to powinno daæ nam wystarczaj±ce klucze.

Choæ warto¶æ klucza jest odbierana, u¿ywana jest w pó¿niejszych wywo³aniach systemowych
w celu tworzenia lub dostêpu do obiektów IPC.

\subsubsection{Polecenie {\tt ipcs}}

Komendê {\tt ipcs} mo¿na u¿yæ w celu otrzymania statusu wszyskitch obiektów IPC 
Systemu V. Linuxowa wersja narzêdzia zosta³a stworzona przez {\em Krishna Balasubramanian\/}.



\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
ipcs     -q:    Poka¿ tylko kolejki wiadomo¶ci
ipcs     -s:    Poka¿ tylko semafory
ipcs     -m:    Poka¿ tylko pamieæ dzielon±
ipcs --help:    Dodatkowe argumenty
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}

Domy¶lnie, wszystkie trzy kategorie obiektów s± pokazywane. Oto przyk³adowe wyj¶cie:

\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
------ Shared Memory Segments --------
shmid     owner     perms     bytes     nattch    status      

------ Semaphore Arrays --------
semid     owner     perms     nsems     status      

------ Message Queues --------
msqid     owner     perms     used-bytes  messages    
0         root      660       5           1           
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}

Powy¿ej widzimy pojedyñcz± kolejkê wiadomo¶ci, która ma identyfikator '0'. Jej 
w³a¶cicielem jest u¿ytkownik {\em root\/}, a jej ósemkowe restrykcje to {\tt 660},
lub {\tt -rw-rw---}. W kolejce jest jedna wiadomo¶æ o ca³kowitym rozmiarze 5 bajtów.

Komenda {\tt ipcs} jest potê¿nym narzêdziem umo¿liwiaj±cym przyjrzenie siê mechanizmowi
sk³adowania obiektów IPC przez j±dro. Poznaj je, u¿ywaj, czcij.


\subsubsection{Komemda {\tt ipcrm}}

Komendê {\tt ipcrm} mo¿esz u¿yæ w celu usuniêcia obiektu IPC z j±dra. Obiekty mog±
byæ u¿ywane poprzez wywo³ania systemowe ( o czym powiemy za chwilê ), jednak
czasami, zw³aszcza w czasie projektowania, zmuszeni jeste¶my do rêcznego usuwania
obiektów IPC. 

\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
ipcrm <msg | sem | shm>  <IPC ID>
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


Musisz okre¶liæ rodzaj obiektu jaki ma zostaæ usuniêty: kolejka wiadomo¶ci 
({\em msg\/}), semafor ({\em sem\/}) lub pamiêæ dzielona ({\em shm\/}). IPC ID mo¿esz
otrzymaæ dziêki poleceniu {\tt ipcs}. Musisz podaæ typ obiektu, gdy¿ 
( jak wspomnieli¶my wcze¶niej ) obiekty ró¿nych typów mog± mieæ ten sam identyfikator.


\subsection{Kolejki wiadomo¶ci}




\subsubsection{Wstêp}

Kolejki wiadomo¶ci najlepiej opisaæ jako wewnêtrznie po³±czon± listê w 
obszarze adresowym j±dra. Wiadomo¶ci mog± byæ przesy³ane do kolejki po kolei oraz
odbierane z kolejki na kilka ró¿nych sposobów. Ka¿da kolejka posiada
unikalny identyfikator.

\subsubsection{Struktury danych: Wewnêtrzne i U¿ytkownika}

Kluczem do ca³kowitego zrozumienia tak z³o¿onego tematu jak IPC Systemu V jest
dok³adne poznanie ró¿nych wewnêtrznych struktur danych przebywaj±cych w j±drze.
Bezpo¶redni dostêp do niektórych z nich jest niezbêdny nawet dla podstawowych
operacji, podczas gdy niektóre przebywaj± na dosyæ niskim poziomie.

\paragraph{Bufor wiadomo¶ci}

Pierwsz± struktur±, której siê przyjrzymy jest {\tt msgbuf}. Ta struktura mo¿e
byæ postrzegana jako {\em szablon\/} dla wiadomo¶ci. Spraw± programisty jest
zdefiniowanie struktury tego typu, jest wa¿ne aby¶ zrozumia³, i¿ {\bf istnieje}
struktura typu {\tt msgbuf}. Jest ona zadeklorowana w {\tt linux/msg.h} nastêpuj±co:


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
/* buffor wiadomo¶ci dla wywo³añ msgsnd i msgrcv */
struct msgbuf {
    long mtype;         /* typ wiadomo¶ci */
    char mtext[1];      /* tekst wiadomo¶ci */
};
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}




Struktura {\tt msgbuf} ma dwóch cz³onków:

\begin{description}
\item[{\tt mtype}] \mbox{}

{\em Typ\/} wiadomo¶ci reprezentowany jako liczba dodatnia.  To {\em musi\/}
byæ liczba dodatnia!

\item[{\tt mtext}] \mbox{}

Wiadomo¶æ.

\end{description}

Mo¿liwo¶æ nadawania okre¶lonej wiadomo¶ci {\em typu\/} dostarcza ci narzêdzia do
tworzenia ró¿norodnych wiadomo¶ci w jednej kolejce. Dla przyk³adu: procesy typu 
klient mog± rozpoznawaæ specjalny numer oznaczaj±cy wiadomo¶æ od serwera, a serwer
bêdzie obs³ugiwa³ inny numer oznaczaj±cy, ¿e jest to wiadomo¶æ od klienta. Inny
scenariusz: aplikacja mo¿e znakowaæ wiadomo¶ci o b³êdach jedynk±, ¿±dania dwójk±,
masz nieograniczone mo¿liwo¶ci.

Nie daj siê zwie¶æ przez nazwê drugiego elementu - {\tt mtext}. Pole to nie jest
zmuszone do przechowywania tablicy znaków, mo¿esz przesy³aæ cokolwiek. Samo to pole
mo¿e znikn±æ z wiadomo¶ci, gdy¿ ca³a struktura mo¿e zostaæ przedefiniowana przez
programistê. Rozwa¿ tak± mo¿liwo¶æ:

\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
struct moj_msgbuf {
        long    mtype;          /* Typ wiadomo¶ci */
        long    id_zadania;     /* Identyfikator ¿±dania */
        struct  klient_info;    /* Stuktura informacji dla klienta */
};
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}

Powy¿ej widzimy strukturê wiadomo¶ci, jednak¿e jest ona nieco zmieniona - 
jeden z jej elemntów zosta³ usuniêty, a na jego miejse pojawi³y siê dwa nowe, z
których jeden jest struktur±! Oto jest piêkno kolejek wiadomo¶ci! J±dro w ¿aden
sposób nie przetwarza przesy³anych danych. Mo¿esz przesy³aæ ka¿d± informacjê.

Niestety istnieje pewien wewnêtrzny limit - maksymalny rozmiar wiadomo¶ci zdefiniowany
jest w {\tt linux/msg.h} nastêpuj±co:
 
\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
#define MSGMAX  4056   /* <= 4056 */   /* maxymalny rozmiar wiadomo¶ci ( bajty ) */
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}

Ca³kowita wiadomo¶æ nie mo¿e byæ wiêksza ni¿ 4056 bajtów, w³±czaj±c w to {\tt mtype}, 
który ma 4 bajty d³ugo¶ci ({\tt long}).


\paragraph{Struktura {\tt msg} w j±drze}

J±dro przechowuje ka¿d± wiadomo¶æ wewn±trz ramki jak± jest struktura {\tt msg}.
Jest ona zdefiniowana w {\tt linux/msg.h}:

\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
/* struktura msg dla ka¿dej wiadomo¶ci */
struct msg {
    struct msg *msg_next;   /* nastêpna wiadomo¶æ w kolejce */
    long  msg_type;          
    char *msg_spot;         /* adres tekst wiadomo¶ci */
    short msg_ts;           /* rozmiar tekstu wiadomo¶ci */
};
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}




\begin{description}
\item[{\tt msg\_next}] \mbox{}
Jest to wska¼nik do nastêpnej wiadomo¶æi. S± one przechowywane jako
pojedyñczo ³±czona lista wewn±trz przestrzeni adresowej j±dra.

\item[{\tt msg\_type}] \mbox{}
Jest to typ wiadomo¶ci ustalony w strukturze {\tt msgbuf} przez u¿ytkownika.

\item[{\tt msg\_spot}] \mbox{}
Wska¼nik do pocz±tku cia³a wiadomo¶ci.

\item[{\tt msg\_ts}] \mbox{}
D³ugo¶æ cia³a lub tekstu wiadomo¶ci.

\end{description}





\paragraph{Struktura {\tt msqid\_ds} w j±drze}

Ka¿dy z trzech typów obiektów IPC posiada wewnêtrzn± strukturê danych utrzymywan±
przez j±dro. Dla kolejek wiadomo¶ci jest to struktura {\tt msqid\_ds}. J±dro tworzy,
przechowuje i utrzymuje kopiê tej struktury dla ka¿dej kolejki wiadomo¶ci 
utworzonej w systemie. Jest ona zdefiniowana w {\tt linux/msg.h}:

\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
/* one msqid structure for each queue on the system */
struct msqid_ds {
    struct ipc_perm msg_perm;
    struct msg *msg_first;  /* pierwsza wiadomo¶æ w kolejce */
    struct msg *msg_last;   /* ostatnia wiadomo¶æ w kolejce */
    time_t msg_stime;       /* czas ostatniego msgsnd */
    time_t msg_rtime;       /* czas ostatniego msgrcv */
    time_t msg_ctime;       /* czas ostatniej zmiany */
    struct wait_queue *wwait;
    struct wait_queue *rwait;
    ushort msg_cbytes;    
    ushort msg_qnum;     
    ushort msg_qbytes;      /* maxymalna ilo¶æ bajtów w kolejce */
    ushort msg_lspid;       /* pid ostatniego msgsnd */
    ushort msg_lrpid;       /* ostatnio odebrany pid */
};
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}

Jakkolwiek niezbyt czêsto bêdziesz siê spotyka³ z cz³onkami tej struktury
zakoñczymy ma³ym opisem ka¿dego z nich:


\begin{description}
\item[{\tt msg\_perm}] \mbox{}

Struktura {\tt ipc\_perm}, która jest zdefiniowana w {\tt linux/ipc.h}. Zawiera
ona informacjê na temat praw kolejki, w³±czaj±c prawa dostêpu oraz informacje o
twórcy kolejki ( uid, etc ).

\item[{\tt msg\_first}] \mbox{}

Wska¼nik do pierwszej wiadomo¶ci w kolejce ( pocz±tku listy ).

\item[{\tt msg\_last}] \mbox{}

Wska¼nik do ostatniej wiadomo¶ci ( koñca listy ).

\item[{\tt msg\_stime}] \mbox{}

Czas ({\tt time\_t}) kiedy wys³ano ostatni± wiadomo¶æ. 

\item[{\tt msg\_rtime}] \mbox{}

Czas ostatniego odebrania wiadomo¶ci z kolejki.

\item[{\tt msg\_ctime}] \mbox{}

Czas ostatniej 'zmiany' dokonanej na kolejce ( wiêcej dowiesz siê pó¿niej ).

\item[{\tt wwait}] \mbox{}

i

\item[{\tt rwait}] \mbox{}

Wska¼niki do {\em kolejki oczekiwania (wait queue)\/} j±dra. U¿ywane s± gdy
operacja na kolejce uwa¿a, ¿e proces ¶pi ( np. kolejka jest pe³na i proces czeka
na otwarcie ).

\item[{\tt msg\_cbytes}] \mbox{}

Suma rozmiarów wszystkich wiadomo¶ci w kolejce.

\item[{\tt msg\_qnum}] \mbox{}

Liczba wiadomo¶ci w kolejce.

\item[{\tt msg\_qbytes}] \mbox{}

Maxymalna liczba bajtów dla kolejki.

\item[{\tt msg\_lspid}] \mbox{}

PID procesu, który jako ostatni wys³a³ wiadomo¶æ.

\item[{\tt msg\_lrpid}] \mbox{}

PID procesu, który jako ostatni odebra³ wiadomo¶æ.

\end{description}


\paragraph{Struktura {\tt ipc\_perm} w j±drze}

J±dro przechowuje pozwolenia obiektów IPC w strukturze typu {\tt ipc\_perm}.
Wewnêtrzna struktura kolejki wiadomo¶ci {\tt msg\_perm} jest w³a¶nie takiego typu,
który zadeklarowany jest w {\tt linux/ipc.h} nastêpuj±co:

\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}

struct ipc_perm
{
  key_t  key;
  ushort uid;   /* euid i egid w³a¶ciciela */
  ushort gid;
  ushort cuid;  /* euid i egid twórcy */
  ushort cgid;
  ushort mode;  /* tryby dostêpu, zobacz flagi trybów poni¿ej */
  ushort seq;   /* numer sekwencji u¿ycia slotu (slot usage sequence number) */
};
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}

Raczej nietrudno odgadn±æ przeznaczenie poszczególnych cz³onków. Klucz przechowywany
razem z obiektem zaiera informacje na temat twórcy oraz w³a¶ciciela obiektu ( mog± siê
ró¿niæ ). Ósemkowe prawa dostêpu s± równie¿ tutaj przechowywane; jako {\tt unsigned short}.
Mamy tu równie¿ {\em sekwencjê u¿ycia slotu\/} na koñcu. Za ka¿dym razem gdy obiekt IPC
zamykany jest via wywo³anie systemowe ( jest niszczony ) warto¶æ ta zwiêkszana jest
przez maxymaln± liczbê obiektów IPC mog±cych przebywaæ w systemie. Nie przejmuj siê
t± warto¶ci±.

{\bf UWAGA:}{\em  Istnieje wspania³a dyskusja na ten temat, oraz na temat powodu
takiego dzia³ania zwi±zanego z bezpieczeñstwem systemu w ksi±¿ce Richarda Stevensa, {\bf UNIX Network Programming}, pp. 125.\/}

\subsubsection{WYWO£ANIE SYSTEMOWE: msgget()}

W celu utworzenia nowej kolejki wiadomo¶ci lub dostêpu do istniej±cej u¿ywamy
wywo³ania {\tt msgget()}.

\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
  WYWO£ANIE SYSTEMOWE: msgget();                                                          

  PROTOTYP: int msgget ( key_t klucz, int msgflg );                                             
    ZWRACA: identyfikator kolejki - sukces                                                       
             -1 - b³±d: errno = EACCESS ( brak prawa dostêpu )
                                EEXIST ( kolejka istnieje, nie mo¿na jej 
					 utworzyæ )
                                EIDRM ( kolejka jest zaznaczona jako do usuniêcia )
                                ENOENT ( kolejka nie istnieje )
                                ENOMEM ( brak pamiêci aby utworzyæ kolejkê )
                                ENOSPC ( maxymalny limit kolejek przekroczony )
  UWAGI: 
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


Pierwszym argumentem {\tt msgget()} jest warto¶æ klucza ( w naszym przypadku
podana przez {\tt ftok()}). Warto¶æ ta porównywana jest do warto¶ci kluczy
kolejek istniej±cych wewn±trz j±dra, w tym momencie otwarcie lub otworzenie kolejki
zale¿y od zawarto¶ci argumentu {\tt msgflg}:


\begin{description}
\item[IPC\_CREAT] \mbox{}

Utwórz kolejkê je¿eli ona nie istnieje.

\item[IPC\_EXCL] \mbox{}

U¿yte razem z IPC\_CREAT zwraca b³±d je¿eli kolejka istnieje.

\end{description}

Je¿eli u¿ywasz samo {\tt IPC\_CREAT} {\tt msgget()} zwraca identyfikator nowo
utworzonej kolejki lub istniej±cej, której warto¶æ klucza jest taka sama.
Je¿eli u¿ywasz {\tt IPC\_EXCL} razem z {\tt IPC\_CREAT} zostanie utworzona nowa
kolejka lub wywo³anie zwróci b³±d. U¿ycie tej flagi gwarantuje nam, ¿e nie istenieje
kolejka z otwartym dostêpem.

Mo¿esz równie¿ z'OR'owaæ dodatkowy ósemkowy tryb z argumentem, gdy¿ ka¿dy
obiekt IPC posiada prawa podobne w dzia³aniu do praw pliku z systemu plików
Unixa !!! 

Utwórzmy prost± funkcjê otwieraj±c± lub tworz±c± kolejkê wiadomo¶ci:

\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
int open_queue( key_t keyval )
{
        int     qid;
        
        if((qid = msgget( keyval, IPC_CREAT | 0660 )) == -1)
        {
                return(-1);
        }
        
        return(qid);
}
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


Zauwa¿, i¿ u¿ywamy ograniczeñ {\tt 0660}. Ta ma³a funkcja zwraca identyfikator
kolejki lub warto¶æ -1. Jedynym argumentem jest warto¶æ klucza.



\subsubsection{WYWO£ANIE SYSTEMOWE: msgsnd()}

Kiedy posiadamy identyfikator kolejki mo¿emy przeprowadzaæ operacje na niej.
Aby wys³aæ wiadomo¶æ do kolejki mo¿emy pos³u¿yæ siê wywo³aniem {\tt msgsnd}:

\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
  WYWO£ANIE SYSTEMOWE: msgsnd();                                                          

  PROTOTYP: int msgsnd ( int msqid, struct msgbuf *msgp, int msgsz, int msgflg );
    ZWRACA: 0 - sukces
             -1 - b³±d: errno = EAGAIN ( kolejka jest pe³na i IPC_NOWAIT jest ustawione )
                                EACCES ( brak dostêpu, brak prawa zapisu )
                                EFAULT ( adres msgp jest niedostêpny lub nieprawid³owy )
                                EIDRM  ( kolejka zosta³a usuniêta )
                                EINTR  ( otrzymano sygna³ podczas próby zapisu )
				EINVAL ( nieprawid³owy identyfikator, ujemny typ
				         lub nieprawid³owy rozmiar wiadomo¶ci ) 
                                ENOMEM ( brak pamiêci do skopiowania bufora wiadomo¶ci )
  UWAGI: 
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


Pierwszy agrument ( {\tt msgsnd} ) jest identyfikatorem zwróconym przez {\tt msgget}.
Drugi ( {\tt msgp} ) to wska¼nik do naszego bufora wiadomo¶ci. Argument {\tt msgsz}
zawiera rozmiar wiadomo¶ci w bajtach, wy³±czaj±c d³ugo¶æ typu ( 4 bajty ).


Argument {\tt msgflg} mo¿e byæ ustawiony na 0 ( ignorowany ) lub na:

\begin{description}
\item[IPC\_NOWAIT] \mbox{}

Je¿eli kolejka jest pe³na wiadomo¶æ nie jest zapisywana, kontrol powraca
do procesu wywo³uj±cego. Je¿eli nie podana proces bêdzie czeka³ na mo¿liwo¶æ zapisu.

\end{description}


Utwórzmy nastêpn± przyk³adow± funkcjê wysy³aj±c± wiadomo¶ci:

\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
int send_message( int qid, struct mymsgbuf *qbuf )
{
        int     result, length;

        /* lenght jest rozmiarem struktury minus sizeof(mtype) */
        length = sizeof(struct mymsgbuf) - sizeof(long);        

        if((result = msgsnd( qid, qbuf, length, 0)) == -1)
        {
                return(-1);
        }
        
        return(result);
}
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}

Ta ma³a funkcja próbuje wys³aæ wiadomo¶æ pobran± z podanego adresu
w kolejkê o podanym identyfikatorze. 

Oto przyk³adowy kod u¿ywaj±cy naszych dwóch funkcji:

\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}

#include <stdio.h>
#include <stdlib.h>
#include <linux/ipc.h>
#include <linux/msg.h>

main()
{
        int    qid;
        key_t  msgkey;
        struct mymsgbuf {
                long    mtype;          /* typ wiadomo¶ci */
                int     request;        /* numer ¿±dania danego dzia³ania */
                double  salary;         /* zap³ata od pracodawcy */
        } msg;

        /* tworzymy warto¶æ klucza IPC */
        msgkey = ftok(".", 'm');

        /* otwieramy/tworzymy kolejkê */
        if(( qid = open_queue( msgkey)) == -1) {
                perror("otwieranie_kolejki");
                exit(1);
        }

        /* nasze przyk³adowe dane */
        msg.mtype   = 1;        /* typ wiadomo¶ci musi byæ dodatni */   
        msg.request = 1;        /* element #1 */
        msg.salary  = 1000.00;  /* element #2 ( mój roczny zarobek! ) */
        
        /* Bomby posz³y! */
        if((send_message( qid, &msg )) == -1) {
                perror("wysy³anie_wiadomo¶ci");
                exit(1);
        }
}
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}

Po utworzeniu/otwarciu naszej kolejki tworzymy bufor z danymi testowymi
({\em zauwa¿ brak danych znakowych - w celu zademonstrowania mo¿liwo¶ci przesy³ania informacji binarnej\/}). 
Wywo³anie {\tt send\_message} przesy³a wiadomo¶æ do kolejki.

Mamy nasz± wiadomo¶æ w kolejce, aby sprawdziæ status kolejki odpal polecenie {\tt
ipcs}. Teraz zajmijmy siê odberaniem informacji z kolejki, do tego celu
s³u¿y wywo³anie systemowe {\tt msgrcv()}:

\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
  WYWO£ANIE SYSTEMOWE: msgrcv();                                                          
  PROTOTYP: int msgrcv ( int msqid, struct msgbuf *msgp, int msgsz, long mtype, int msgflg );
    ZWRACA: ilo¶æ bajtów skopiowan± do bufora wiadomo¶ci
             -1 - b³±d: errno = E2BIG  ( d³ugo¶æ wiadomo¶ci jest wiêksza ni¿ msgsz, 
	                                 brak MSG_NOERROR)
                                EACCES ( odczyt zabroniony )
                                EFAULT ( adres wskazywany przez msgp jest nieprawid³owy )                             EIDRM  (Queue was removed during retrieval)
                                EINTR  ( przerwano z powodu nadchadz±cego sygna³u )
                                EINVAL ( nieprawid³owy msgqid invalid lub msgsz ujemny )
                                ENOMSG ( ustawiono IPC_NOWAIT, a nie ma w kolejce
					 wiadomo¶ci spe³niaj±cej ¿±danie )
  UWAGI: 
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}

Pierwszy argument okre¶la kolejkê ( powinni¶my go dostaæ po wywo³aniu {\tt msgget}).
Drugi argument ({\tt msgp}) jest adresem bufora dla otrzymanej wiadomo¶ci. Trzeci
argument ({\tt msgsz}) okre¶la rozmiar struktury bufora wiadomo¶ci, wy³±czaj±c
rozmiar cz³onka {\tt mtype}. Pamietaj, ¿e mo¿na to ³atwo obliczyæ:


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
msgsz = sizeof(struct mymsgbuf) - sizeof(long);
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}

Czwarty argument ({\tt mtype}) okre¶la {\em type\/} typ wiadomo¶ci do odbioru.
J±dro przeszyka kolejkê w poszukiwaniu najstarszej wiadomo¶ci o podanym typie
i prze¶le jej kopie pod adres wskazywany przez argument {\tt msgp}. Istnieje jeden
wyj±tek: je¿eli {\tt mtype} ma warto¶æ zero zostanie przes³ana najstarsza wiadomo¶æ
nie zwracaj±c uwagi na typ.

Je¿eli podano {\bf IPC\_NOWAIT} jako flagê, i brak wiadomo¶ci w kolejce wywo³anie
zwróci ENOMSG. W innym wypadku proces bêdzie czeka³ na wiadomo¶æ spe³niaj±c± wymagania
{\tt msgrcv()}. Je¿eli kolejka zosta³a skasowana podczas gdy klient czeka³ na wiadomo¶æ
zostanie zwrócone EIDRM. Natomiast EINTR otrzymamy je¿eli sygna³ nadszed³ gdy
proces oczekiwa³ na wiadomo¶æ.

Oto prosta funkcja odbieraj±ca wiadomo¶æ z kolejki:

\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
int read_message( int qid, long type, struct mymsgbuf *qbuf )
{
        int     result, length;

        /* lenght jest rozmiarem struktury minus sizeof(mtype) */
        length = sizeof(struct mymsgbuf) - sizeof(long);        

        if((result = msgrcv( qid, qbuf, length, type,  0)) == -1)
        {
                return(-1);
        }
        
        return(result);
}
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}

Po szczê¶liwym odebraniu wiadomo¶ci jest ona usuwana z kolejki.

Bit {\bf MSG\_NOERROR} w argumencie {\tt msgflg} daje nam dodatkowe mo¿liwo¶ci.
Je¿eli rozmiar wiadomo¶ci jest wiêkszy ni¿ {\tt msgsz}, a my ustawili¶my flagê
{\bf MSG\_NOERROR} wiadomo¶æ zostanie obciêta, otrzymamy tylko {\tt msgsz} bajtów.
Normalnie wywo³anie {\tt msgrcv()} zwraca -1 ({\bf E2BIG}), a wiadomo¶æ pozostaje
w kolejce. Takie zachowanie umo¿liwia nam napisanie funkcji, która bêdzie przeszukiwaæ
kolejkê w poszukiwaniu odpowiedniej wiadomo¶ci:


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
int peek_message( int qid, long type )
{
        int     result, length;

        if((result = msgrcv( qid, NULL, 0, type,  IPC_NOWAIT)) == -1)
        {
                if(errno == E2BIG)
                        return(TRUE);
        }
        
        return(FALSE);
}
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}

Jak widzisz nie podali¶my adresu bufora oraz rozmiaru. Zrobili¶my to dlatego, i¿
{\em chcemy\/} aby wywo³anie nie powiod³o siê. Jednocze¶nie sprawdzamy {\bf E2BIG},
który wskazuje czy istnieje w kolejce wiadomo¶æ o odpowiednim typie.
Funkcja zwraca {\bf TRUE} je¿eli istnieje wiadomo¶æ o poszukiwanym typie, oraz
{\bf FALSE} je¿eli nie. Zauwa¿, ¿e ustawiamy flagê {\bf IPC\_NOWAIT}, która
zapobiega czekaniu na odpowiedni± wiadomo¶æ.


\subsubsection{WYWO£ANIE SYSTEMOWE: msgctl()}

Podczas tworzenia tych przyk³adowych funkcji pozna³e¶ proste i eleganckie podej¶cie
do tworzenia i u¿ywania kolejek wiadomo¶ci. Teraz przedyskutujemy bezpo¶redni±
manipulacjê wewnêtrznych struktur zwi±zanych z dan± kolejk±.

Aby kontrolowaæ kolejkê u¿ywamy wywo³ania systemowego {\tt msgctl()}.


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
  WYWO£ANIE SYSTEMOWE: msgctl();
  PROTOTYP: int msgctl ( int msgqid, int cmd, struct msqid_ds *buf );
    ZWRACA: 0 - sukces
             -1 - b³±d: errno = EACCES ( odczyt niedozwolony a cmd jest usawione na IPC_STAT )
                                EFAULT ( adres wskazywany przez buf jest nieprawid³owy dla
				         komend IPC_SET i IPC_STAT )
                                EIDRM  ( kolejka zosta³a usuniêta podczas odczytu (retrieve) )
                                EINVAL ( nieprawid³owe msgqid lub msgsz ujemne )
                                EPERM  ( komendy IPC_SET lub IPC_RMID zosta³y wybrane, lecz
                                         proces nie mo¿e zapisywaæ lub nie ma dostêpu
					 do kolejki )
  UWAGI: 
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}

Logika podpowiada ci, i¿ bezpo¶rednia manipulacja wewnêtrznych struktur j±dra
mo¿e prowadziæ do nocnych igraszek. Niestety, odpowiedzialno¶æ spoczywaj±ca na
programi¶cie mo¿e zostaæ zaklasyfikowana jako zabawa pod warunkiem, ¿e lubisz 
za¶miecaæ podsystem IPC. Wywo³uj±c {\tt msgctl()} z odpowiednio dobranymi poleceniami
mo¿esz manipulowaæ jednostki, które zbyt ³atwo nie doprowadz± systemu do upadku.
Przyj¿yjmy siê tym komendom:

\begin{description}
\item[{\bf IPC\_STAT}] \mbox{}

Odczytuje strukturê msqid\_ds z kolejki i przechowuje j± pod
adresem wskazywanym przez argument buf.

\item[{\bf IPC\_SET}] \mbox{}

Ustawia warto¶æ ipc\_perm ( cz³onka struktury msqid\_ds ).
Warto¶æ pobierana jest z argumentu buf.

\item[{\bf IPC\_RMID}] \mbox{}

Usuwa kolejkê z j±dra.

\end{description}

Przypomnij sobie nasz± dyskusjê na temat struktury {\tt msqid\_ds}.
J±dro przechowuje kopiê tej struktury dla ka¿dej kolejki istniej±cej w systemie.
U¿ywaj±c polecenia {\bf IPC\_STAT} mo¿emy otrzymaæ kopiê tej struktury.

Przyj¿yjmy siê funkcji odbieraj±cej i kopiuj±cej tê strukturê pod podany adres:

\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
int get_queue_ds( int qid, struct msgqid_ds *qbuf )
{
        if( msgctl( qid, IPC_STAT, qbuf) == -1)
        {
                return(-1);
        }
        
        return(0);
}
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}

Je¿eli nie uda³o nam siê skopiowaæ wewnêtrznego bufora zwracamy -1. Je¿eli wszystko
posz³o dobrze zwracamy 0, a podany bufor powinien zawieraæ kopiê wewnêtrznej struktury
dla kolejki reprezentowanej przez podany identyfikator ({\tt qid}).

Mamy ju¿ kopiê wewnêtrznej struktury dla kolejki, zdajmy sobie pytanie co mo¿emy
zmieniæ? Jedynym elementem, który mo¿emy zmieniæ jest struktura {\tt ipc\_perm}.
Zawiera ona prawa dostêpu oraz informacje o twórcy i w³a¶cicielu kolejki.
Jednak¿e, mo¿emy zmieniæ jedynie {\tt mode}, {\tt uid} i {\tt gid}, czyli
id w³a¶ciciela, id grupy, oraz prawa dostêpu do kolejki.

Utwórzmy funkcjê zmieniaj±c± prawa dostêpu do kolejki. Musimy je przekazaæ jako tablicê
znaków ( np.: {\em ``660''\/}).


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
int change_queue_mode( int qid, char *mode )
{
        struct msqid_ds tmpbuf;

        /* pobierz kopiê wewnêtrznej struktury */
        get_queue_ds( qid, &tmpbuf);

        /*  zmieñ prawa dostêpu u¿ywaj±c starego triku */
        sscanf(mode, "%ho", &tmpbuf.msg_perm.mode);

        /* uaktualnij wewnêtrzn± strukturê */
        if( msgctl( qid, IPC_SET, &tmpbuf) == -1)
        {
                return(-1);
        }
        
        return(0);
}
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


Pobieramy kopiê struktury za pomoc± wywo³ania naszej funckji {\tt get\_queue\_ds}.
Nastêpnie wywo³ujemy {\tt sscanf()} aby zmieniæ {\tt mode} w strukturze {\tt msg\_perm}.
Zmian dokonuje wywo³anie {\tt msgctl()} z poleceniem {\bf IPC\_SET}.

{\em B¡D¯ OSTRO¯NY!\/} Istnieje mo¿liwo¶æ zablokowania siebie zmieniaj±c prawa dostêpu
dla kolejki! Pamiêtaj, ¿e takie obiekty IPC nie znikaj± do czasu poprawbengo usuniêcia
lub restartu systemu. Nawet je¿eli nie mo¿esz zobaczyæ kolejki za pomoc± {\tt ipcs}
nie oznacza to ¿e jej tam nie ma.

\begin{quotation}
{\em Aby to zademonstrowaæ przedstawiê pewn± zabawn± anegdotê. Kiedy uczy³em
budowy wewnêtrznej Unixa na Uniwersytecie Po³udniowej Florydy wpad³em w pewn±
zawstydzaj±c± blokadê. Dzieñ wcze¶niej przed zajêciami po³±czy³em siê z serwerem 
laboratoryjnym w celu kompilacji
i przetestowania pracy laboratoryjnej na dany tydzieñ. Podczas testowania 
zda³em sobie sprawê, i¿ zrobi³em literówkê w kodzie odpowiedzialnym za zmianê 
praw dostêpu
do kolejki. Jednak¿e gdy próbowa³em zmieniæ prawa dostêpu z "660" na "600" straci³em 
prawa do w³asnej kolejki. Nie mog³em przetestowaæ programu
w tym samym obszarze katalogu domowego, poniewa¿ u¿y³em ftok() do utworzenia
klucza IPC ( próbowa³em u¿yæ kolejki do której nie mia³em prawa ). Zakoñczy³o siê
to na skontaktowaniu siê z lokalnym administratorem rano przed zajêciami,
t³umaczeniu mu przez godzinê czym jest kolejka wiadomo¶ci i dlaczego potrzebujê
uruchomiæ ipcrm. grrrr.\/}
\end{quotation}

Po pomy¶lnym odebraniu wiadomo¶ci zostaje ona usuniêta z kolejki. Jednak, jak
wspomnia³em wcze¶niej, obiekty IPC pozostaj± w systemie do czasu usuniêcia lub
restartu. Zatem, nasza kolejka istnieje wewn±trz j±dra, gotowa do u¿ytku d³ugo po
tym jak nasza wiadomo¶æ znikne³a. Aby dokoñczyæ cyklu ¿yciowego kolejki powinni¶my
j± usun±æ za pomoc± {\tt msgctl()}, podaj±c jako polecenie {\bf IPC\_RMID}:


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
int remove_queue( int qid )
{
        if( msgctl( qid, IPC_RMID, 0) == -1)
        {
                return(-1);
        }
        
        return(0);
}
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


Powy¿sza funkcja zwraca 0 po usuniêciu kolejki, je¿eli siê to nie uda³o zwracane jet -1.
Usuwanie kolejki jest z natury atomowe, zatem jakiekolwiek próby dostêpu do kolejki
zakoñczon± siê marnie.


\subsubsection{msgtool: Interaktywny manipulator kolejk± wiadomo¶ci}

Niewielu mo¿e zaprzeczyæ korzy¶ci p³yn±cych z dostêpu do dok³adnuch technicznych wiadomo¶ci.
Takie materia³y dostarczaj± ogromny mechanizm poznawania i uczenia siê nowych obszarów.
Podobnie jak posiadanie przyk³adów towarzysz±cych informacjom technicznym przy¶pieszy
i wzmocni proces uczenia.

Do tej pory, jedynymi u¿ytecznymi przyk³adami by³y nasze przyk³adowe funkcje
manipuluj±ce kolejk± wiadomo¶ci. S± one bardzo u¿yteczne, jednak nie zosta³y one
przedstawnione w sposób zapewniaj±cy dalsz± naukê i eksperymentowanie.
W tym celu prezentujê {\em msgtool\/} - interaktywny program zarz±dzaj±cy kolejkami
wiadomo¶ci, który mo¿esz uruchomiæ w linii poleceñ. Jego g³ównym celem jest
dalsza edukacja, jednocze¶nie mo¿e zostaæ u¿yty w zwyk³ych zastosowaniach dostarczaj±c
mo¿liwo¶æ manipulacji kolejkami standardowym skryptom pow³oki.


\paragraph{Wprowadzenie}

Program {\tt msgtool} opiera swoje dzia³anie na dostarczonych argumentach.
To czyni go u¿ytecznym we wszelkich skryptach. Wszelkie mo¿liwo¶ci jak:
tworzenie, wysy³anie, odbieranie, zmiana praw dostêpu oraz usuwanie kolejki.
Obecnie u¿ywa on tablic znaków dla danych, umo¿liwiaj±c wysy³anie textowych
wiadomo¶ci. Obs³ugê dodatkowych typów danych pozostawiam czytelnikowyi jako
æwiczenie.

\paragraph{Sk³adnia wywo³ania}


\subparagraph{Wysy³anie wiadomo¶ci}

\begin{verbatim}
msgtool w (type) "text"
\end{verbatim}


\subparagraph{Odbieranie wiadomo¶ci}

\begin{verbatim}
msgtool o (type)
\end{verbatim}





\subparagraph{Zmiana praw dostêpu (trybu)}

\begin{verbatim}
msgtool m (tryb)
\end{verbatim}


\subparagraph{Usuwanie kolejki}

\begin{verbatim}
msgtool u 
\end{verbatim}

\paragraph{Przyk³ady}

\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
msgtool  w   1 test
msgtool  w   5 test
msgtool  w   1 "To jest test"
msgtool  o   1
msgtool  u
msgtool  t   660
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


\paragraph{¬ród³o}

{\tt msgtool}

Nastêpuj±cy kod ¼ród³owy to {\tt msgtool}. Powinien skompilowaæ siê bez problemu
na nowszych ( przyzwoitych ) wersjach j±dra, które wspieraj± System V IPC. Pamiêtaj
o w³±czeniu IPC Systemu V podczas rekompilacji j±dra!

Program {\em utowrzy\/} kolejkê wiadomo¶ci je¿eli jeszcze nie istnieje, bez wzglêdu
na rodzaj ¿±danego dzia³ania.

\begin{quotation}
{\bf UWAGA:} {\em Poniewa¿ narzêdzie to u¿ywa funkcji ftok() do wygenerowania
klucza IPC mo¿esz zaobserwowaæ konflikty katalogów. Je¿eli gdziekolwiek w swoim 
skrypcie zmienisz katalog prawdopodobnie program nie zadzia³a. Rozwi±zaniem
mog³oby byæ zakodowanie ¶cie¿ki wewn±trz programu ( np.: "/tmp/msgtool" ),
lub przekazywanie ¶cie¿ki jako parametru wywo³ania. \/}
\end{quotation}




\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}

/*****************************************************************************
 Zaczerpniêto z "Linux Programmer's Guide - Rozdzia³ 6"
 (C)opyright 1994-1995, Scott Burkett
 ***************************************************************************** 
 MODU£: msgtool.c
 *****************************************************************************
 Narzêdzie linii poleceñ do majstrowania z kolejkami wiadomo¶ci stylu SysV
 *****************************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/msg.h>

#define MAX_SEND_SIZE 80

struct mymsgbuf {
        long mtype;
        char mtext[MAX_SEND_SIZE];
};

void send_message(int qid, struct mymsgbuf *qbuf, long type, char *text);
void read_message(int qid, struct mymsgbuf *qbuf, long type);
void remove_queue(int qid);
void change_queue_mode(int qid, char *mode);
void usage(void);


int main(int argc, char *argv[])
{
        key_t key;
        int   msgqueue_id;
        struct mymsgbuf qbuf;

        if(argc == 1)
                usage();

        /* utwórz unikalny klucz poprzez wywo³anie ftok() */
        key = ftok(".", 'm');

        /* otwórz kolejkê - utwórz je¿eli trzeba */
        if((msgqueue_id = msgget(key, IPC_CREAT|0660)) == -1) {
                perror("msgget");
                exit(1);
        }
        
        switch(tolower(argv[1][0]))
        {
                case 'w': send_message(msgqueue_id, (struct mymsgbuf *)&qbuf,
                                       atol(argv[2]), argv[3]); 
                          break;
                case 'o': read_message(msgqueue_id, &qbuf, atol(argv[2])); 
                          break;
                case 'u': remove_queue(msgqueue_id); 
                          break;        
                case 't': change_queue_mode(msgqueue_id, argv[2]); 
                          break;

                 default: usage();

        }
        
        return(0);
}

void send_message(int qid, struct mymsgbuf *qbuf, long type, char *text)
{
        /* wy¶lij wiadomo¶æ do kolejki */
        printf("Wysy³anie wiadomo¶ci ...\n");
        qbuf->mtype = type;
        strcpy(qbuf->mtext, text);

        if((msgsnd(qid, (struct msgbuf *)qbuf,
                strlen(qbuf->mtext)+1, 0)) ==-1)
        {
                perror("msgsnd");
                exit(1);
        }
}

void read_message(int qid, struct mymsgbuf *qbuf, long type)
{
        /* odczytaj wiadomo¶æ z kolejki */
        printf("Odczytywanie wiadomo¶ci ...\n");
        qbuf->mtype = type;
        msgrcv(qid, (struct msgbuf *)qbuf, MAX_SEND_SIZE, type, 0);
        
        printf("Typ: %ld Tekst: %s\n", qbuf->mtype, qbuf->mtext);
}

void remove_queue(int qid)
{
        /* Remove the queue */
        msgctl(qid, IPC_RMID, 0);
}

void change_queue_mode(int qid, char *mode)
{
        struct msqid_ds myqueue_ds;

        /* pobierz informacje */
        msgctl(qid, IPC_STAT, &myqueue_ds);

        /* konwertuj i za³aduj tryb */
        sscanf(mode, "%ho", &myqueue_ds.msg_perm.mode);

        /* uaktualnij tryb */
        msgctl(qid, IPC_SET, &myqueue_ds);
}

void usage(void)
{
        fprintf(stderr, "msgtool - Narzêdzie do majstrowania przy kolejkach msg\n");
        fprintf(stderr, "\nU¯YCIE: msgtool (w)y¶lij <typ> <tekst>\n");
        fprintf(stderr, "                (o)dbierz <typ>\n");
        fprintf(stderr, "                (u)suñ\n");
        fprintf(stderr, "                (t)ryb <ósemkowy tryb>\n");
        exit(1);
}

\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}



\subsection{Semafory}

\subsubsection{Podstawy}

Semafory mo¿na opisaæ jako liczniki u¿ywane do kontroli dostêpu do dzielonych 
zasobów przez ró¿ne procesy. Najczê¶ciej u¿ywa siê ich do blokowania dostêpu
do zasobu podczas gdy jaki¶ proces przeprowadza na nim operacje. Uwa¿a siê, i¿
najtrudniejszymi do zrozumienia w¶ród obiektów IPC s± semafory. W celu pe³nego
zrozumienia ich dzia³ania zaczniemy od krótkiego opisu, dopiero po tym
przejdziemy do wywo³añ systemowych i sposobu u¿ycia.

{\em Semafor\/} - urz±dzenia sygnalizacyjne przy torze kolejowym, podaj±ce okre¶lone
sygna³y, zapewniajacê prawid³owo¶æ w ruchu poci±gów. To samo mo¿emy powiedzieæ
na temat prostego semafora. Je¿eli jest on {\em w³±czony\/} ( ramiona w górze ) zasób
jest dostêpny ( mo¿emy przejechaæ ). Gdy semafor jest {\em wy³±czony\/} ( ramiona w dole ) zasób jest
niedostêpny ( musimy czekaæ ).

Ten prosty przyk³ad ukazyje jedynie podstawy, nale¿y sobie zdaæ sprawê, i¿
semafory zaimplementowane s± jako {\em uk³ady\/}. Oczywi¶cie uk³ad mo¿e zawieraæ
tylko jeden semafor, tak jak w naszym przyk³adzie.

Mo¿emy równie¿ podej¶æ do zagadnienia semaforów w inny sposób - jako {\em liczniki zasobów\/}.
Wyobra¿my sobie inny rzeczywisty scenariusz. Wyobra¿ sobie zarz±dcê drukowania (spooler)
obs³uguj±cego wiele drukarek, ka¿da drukarka obs³uguje wiele ¿±dañ wydruku. Nasz
hipotetyczny zarz±dca drukowania bêdzie obs³ugiwa³ uk³ad semaforów w celu
monitorowania dostêpu do ka¿dej z drukarek.

Za³u¿my, ¿e mamy 5 dostêpnych drukarek. Nasz zarz±dca tworzy zestaw semaforów 
zawieraj±cy 5 semaforów, po jednym dla drukarki. Ka¿da z drukarek jest zdolna
do fizycznego drukowania jednego zadania, ka¿dy z semaforów zainicjujemy warto¶ci±
1 oznaczaj±c±, ¿e drukarka jest pod³±czona i gotowa na ¿±danie.

Ja¶ wysy³a ¿±danie wydruku do zarz±dcy. Zarz±dca spogl±da na zestaw semaforów i
wyszukuje pierwszego semafora, który równa siê 1. Przed wys³aniem ¿±dania do drukarki
zarz±dca zmniejsza o jeden u¿ywany semafor. Teraz warto¶ci± semaforu jest 0.
W ¶wiecie Systemu V semafor ustawiony na 0 oznacza 100\% u¿ycia. W naszym
przyk³adzie ¿adne inne ¿±danie nie mo¿e zostaæ przes³ane do tej drukarki a¿ do
czasu zmiany warto¶ci. 

Kiedy zadanie Jasia zostanie wykonane zarz±dca zinkrementuje warto¶æ semaforu
odpowiadaj±cego za u¿yt± drukarkê. Warto¶cia semaforu staje siê 1 - drukarka jest
dostêpna. Kiedy wszystkie semafory s± ustawione na 1 oznacza to brak dostêpnych drukarek.

Nie daj siê zwie¶æ inicjalizacji semaforu jedynk±. Kiedy u¿ywamy semaforów jako
liczników zasobów mo¿emy je inicjowaæ {\em ka¿d± dodatni± warto¶ci± \/}. Gdyby
ka¿da z drukarek potrafi³a obs³u¿yæ 10 zadañ wydruku jednocze¶nie, ustawiliby¶my
semafory warto¶ci± 10. W nastêpnym rozdziale odkryjesz powi±zania semaforów
z segmentami dzielonej pamiêci, które bêd± dzia³aæ jako {\em wartownicy \/} zapobiegaj±cy
wielu zapisom jednocze¶nie.

Zanim siêgniemy do wywo³añ systemowych przyj¿yjmy siê strukturom wykorzystywanym
podczas operowania semaforami.


\subsubsection{Wewnêtrzne struktury j±dra}

Przyj¿yjmy siê strukturom utrzymywanym przez jadro dla zestawów semaforów.


\paragraph{Struktura {\tt semid\_ds} w j±drze}

Tak jak w przypadku kolejek wiadomo¶ci j±dro utrzymuje specjaln± strukturê dla
ka¿dego zestawu semaforów, istnieje ona wewn±trz obszaru adresowego j±dra.
Struktura ta jest typu {\tt semid\_ds}, który zdefiniowany jest w {\tt linux/sem.h}:


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
        /* jedna struktura semid dla ka¿dego zestawu semaforów w systemie */
        struct semid_ds {
                struct ipc_perm sem_perm;       /* restrykcje .. zobacz ipc.h */
                time_t          sem_otime;      /* czas ostatniej operacji semop */
                time_t          sem_ctime;      /* czas ostatniej zmiany */
                struct sem      *sem_base;      /* wka¼nik do pierwszego semaforu w tablicy */
                struct wait_queue *eventn;
                struct wait_queue *eventz;
                struct sem_undo  *undo;         /* odwo³aj ¿±dania dla tej tablicy */
                ushort          sem_nsems;      /* liczba semaforów w tablicy */
        };
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}

Tak jak w przypadku kolejek wiadomo¶ci, operacje na tej strukturze przeprowadzane
s± przez specjalne wywo³anie systemowe i tylko przez nie, nie powiniene¶ zabawiaæ 
siê :) z t± struktur± w inny sposób. Opis niektórych pól:

\begin{description}
\item[{\tt sem\_perm}] \mbox{}

Jest to struktura typu {\tt ipc\_perm}, który jest zdefiniowany w {\tt linux/ipc.h}.
Przechowuje prawa dostêpu, oraz informacje o twórcy i w³a¶cicielu zestawu.

\item[{\tt sem\_otime}] \mbox{}

Czas ostaniej operacji {\tt semop()} ( wiêcej o tym za chwilkê )

\item[{\tt sem\_ctime}] \mbox{}

Czas ostatniej zmiany struktury ( np.: zmiana praw, itp. )

\item[{\tt sem\_base}] \mbox{}

Wska¼nik do pierwszego semaforu w tablicy ( zobacz nastêpn± strukturê )

\item[{\tt sem\_undo}] \mbox{}

Liczba ¿±dañ {\em odwo³ania (undo)\/} dla tej tablicy ( wiêcej za chwilê )

\item[{\tt sem\_nsems}] \mbox{}

Liczba semaforów w zestawie ( tablicy ).

\end{description}


\paragraph{Struktura {\tt sem} w j±drze}

W strukturze {\tt semid\_ds} istnieje wska¼nik do podstawy tablicy semaforów.
Ka¿dy cz³onek tej tablicy jest struktur± typu {\tt sem}, która jest zdefiniowana
w {\tt linux/sem.h}:

\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}

        /* jedna struktura dla ka¿dego semaforu w systemie. */
        struct sem {
                short   sempid;         /* pid ostatniej operacji */
                ushort  semval;         /* obecna warto¶æ */
                ushort  semncnt;        /* numer procesów czekaj±cych na zwiêkszenie semval */
                ushort  semzcnt;        /* numer procesów czekaj±cych na semval = 0 */
        };
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


\begin{description}
\item[{\tt sem\_pid}] \mbox{}

PID ( ID procesu ), który przeprowadzi³ ostatni± operacjê

\item[{\tt sem\_semval}] \mbox{}

Obecna warto¶æ semaforu

\item[{\tt sem\_semncnt}] \mbox{}

Liczba procesów oczekuj±cych dostêpu do zasobu

\item[{\tt sem\_semzcnt}] \mbox{}

Liczba procesów oczekuj±cych na 100\% u¿ycie zasobów

\end{description}





\subsubsection{WYWO£ANIE SYSTEMOWE: semget()}

W celu utworzenia nowego zestawu semaforów, lub dostêpu do istniej±cego,
u¿ywamy wywo³ania systemowego {\tt semget()}.


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
  WYWO£ANIE SYSTEMOWE: semget();                                                          

  PROTOTYP: int semget ( key_t key, int nsems, int semflg );                                             
    ZWRACA: indentyfikator IPC zestawu, je¿eli sukces
             -1 - b³±d: errno = EACCESS ( brak prawa dostêpu )
                                EEXIST ( zestaw istnieje, nie mo¿na utworzyæ (IPC_EXCL) )
                                EIDRM ( zestaw zaznaczony do usuniêcia )
                                ENOENT ( zestaw nie istnieje, nie podano IPC_CREAT )
                                ENOMEM ( brak pamiêci do utworzenia zestawu )
                                ENOSPC ( limit ilo¶ci zestawów przekroczony )
  UWAGI: 
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}

Pierwszym argumentem dla {\tt semget()} jest warto¶æ klucza ( w naszym przypadku
zwrócona przez {\tt ftok()}). Warto¶æ ta porównywana jest do istniej±cych
kluczy. Teraz operacje otworzenia lub dostêpu zale¿± od zawarto¶ci argumentu
{\tt semflg}:

\begin{description}
\item[IPC\_CREAT] \mbox{}

Utwórz zestaw semaforów je¿eli jeszcze nie istnieje w j±drze.

\item[IPC\_EXCL] \mbox{}

U¿yte z IPC\_CREAT zwraca b³±d je¿eli zestaw ju¿ isnieje.

\end{description}

Je¿eli u¿ywamy samego {\tt IPC\_CREAT} {\tt semget()} zwraca identyfikator
zestawu, który zosta³ utworzony lub identyfikator ju¿ istniej±cego, który
posiada podan± warto¶æ klucza. Je¿eli podano równie¿ {\tt IPC\_EXCL} zostanie
utworzony nowy zestaw lub wywo³anie zwróci -1. Podanie tylko {\tt IPC\_EXCL} jest
bezu¿yteczne, jednak w po³±czeniu z {\tt IPC\_CREAT} gwarantuje nam, i¿
nie u¿ywamy istniej±cego semaforu.

Tak jak dla ka¿dej innej formy IPC Systemu V mo¿emy podaæ ósemkowe prawa dostêpu,
które zostan± z'OR'owane z umask± aby utworzyæ prawa dostêpu dla zestawu.

Argument {\tt nsems} okre¶la liczbê semaforów, które zostan± utworzone dla
nowego zestawu. Reprezentuje to liczbê drukarek w naszym przyk³adzie.
Maxymalna liczba semaforów jest zdefiniowana w {\tt linux/sem.h\/}:

\begin{verbatim}
        #define SEMMSL  32      /* <=512 maxymalna liczba semaforów dla id */
\end{verbatim}

Zauwa¿, i¿ arument {\tt nsems} jest ignorowany gdy otwieramy ju¿ instniej±cy
zestaw.

Stwórzmy szkielet funkcji otwieraj±cej lub tworz±cej zestaw semaforów:

\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
int open_semaphore_set( key_t keyval, int numsems )
{
        int     sid;

        if ( ! numsems )
                return(-1);
        
        if((sid = semget( mykey, numsems, IPC_CREAT | 0660 )) == -1)
        {
                return(-1);
        }
        
        return(sid);
}
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}

Zauwa¿, ¿e u¿ywamy praw dostêpu {\tt 0660}. Nasza prosta funkcja zwraca identyfikator
zestawu ({\tt int}) lub -1, je¿eli co¶ nie posz³o. Musimy jej podaæ warto¶æ klucza, 
oraz liczbê semaforów, dla których mamy zaj±æ miejsce, pod warunkiem, ¿e tworzymy
zestaw. W przyk³adzie zaprezentowanym pod koniec rozdzia³u u¿ywamy równie¿ flagê
IPC\_EXCL w celu sprawdzenia czy semafor istnieje.


\subsubsection{WYWO£ANIE SYSTEMOWE: semop()}

\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
  WYWO£ANIE SYSTEMOWE: semop();                                                          
  PROTOTYP: int semop ( int semid, struct sembuf *sops, unsigned nsops);
    ZWRACA: 0 - sukces ( przeprowadzono wszystkie operacje )
            -1 - b³±d: errno = E2BIG ( nsops wiêkszy od maxymalnej liczby 
	                               dozwolonych operacji atomowych )
                               EACCESS ( brak prawa dostêpu )
                               EAGAIN ( IPC_NOWAIT ustawione, nie mo¿na 
					przeprowadziæ operacji )
                               EFAULT ( nieprawid³owy adres wskazywany przez 
					sops )
                               EIDRM ( zestaw zosta³ usuniêty )
                               EINTR ( otrzymano sygna³ w czasie spania )
                               EINVAL ( zestaw nie istnieje lub nieprawid³owy semid )
			       ENOMEM ( SEM_UNDO ustawione, brak pamiêci aby utworzyæ strukturê anulowania (undo) )
                               ERANGE ( warto¶æ semoforu poza zakresem )
  UWAGI: 
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}

Pierwszym argumentem dla {\tt semop()} jest klucz ( w naszym przypadku zwrócony przez 
{\tt semget}). Drugi argument ({\tt sops}) jest wska¼nikiem do tablicy {\em operacji \/},
które maj± zostaæ przeprowadzone na grupie semaforów. Trzeci argument ({\tt nsops}) jest
liczb± operacji w tablicy.


Argument {\tt sops} wskazuje tablicê typu {\tt sembuf}, który jest zdefiniowany
w {\tt linux/sem.h}:

\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
        /* wywo³anie systemowe semop bierze tablicê takich struktur */
        struct sembuf {
                ushort  sem_num;        /* index semafora w tablicy */
                short   sem_op;         /* opercja */
                short   sem_flg;        /* flagi oparacji */
        };
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}




\begin{description}
\item[{\tt sem\_num}] \mbox{}

Numer semafora którym jeste¶ zainteresowany

\item[{\tt sem\_op}] \mbox{}

Operacja do wykonania ( dodatnia, ujemna lub zero )

\item[{\tt sem\_flg}] \mbox{}

Flagi operacji

\end{description}


Je¿eli {\tt sem\_op} jest ujemny jego warto¶æ zostaje odjêta od semafora. Odpowiada to
u¿ywaniu zasobów kontrolowanych lub monitorowanych przez semafor. Je¿eli nie podano
{\bf IPC\_NOWAIT} proces wywo³uj±cy ¶pi do czasu a¿ wymagana liczba zasobów jest
dostêpna ( inny proces zwolni³ jakie¶ ).

Je¿eli {\tt sem\_op} jest dodatni jego warto¶æ jest dodawana do semafora.
Odpowiada to zwolnieniu zasobów. Zasoby powinny byæ zawsze zwalniane je¿eli nie s±
d³u¿ej u¿ywane!

Je¿eli {\tt sem\_op} jest zerem proces bêdzie spa³ do czasu a¿ semafor bêdzie mia³ warto¶æ zera.
Odpowiada to 100\% u¿ycia. Dobrym przyk³adem jest demon dzia³aj±cy z prawami roota,
który bêdzie dynamicznie zmienia³ rozmiar zbioru semaforów je¿eli ten bêdzie w 100\%
u¿yty.

W celu wyt³umaczenia wywo³ania {\tt semop} przywo³ajmy nasz przyk³ad z drukarkami.
Za³u¿my, i¿ mamy tylko jedn± drukarkê, która potrafi drukowaæ tylko jedn± pracê.
Utworzymy zestaw tylko z jednym semaforem ( tylko jedna drukarka ) i zainicjujemy
go warto¶ci± jeden ( tylko jedna praca ).

Za ka¿dym razem gdy chcemy wys³aæ pracê do drukarki musimy upewniæ siê czy
jest ona dostêpna. Robimy to próbuj±c otrzymaæ jedn± {\em jednostkê \/} z semafora.
Za³adujmy tablicê sembuf aby tego dokonaæ:

\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
        struct sembuf sem_lock = { 0, -1, IPC_NOWAIT };
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}

Tak zainicjowana struktura wymusza dodanie -1 do semafora numer 0. Inaczej mówi±c
jedna jednostka zasobu zostanie u¿yta z semafora numer 0. Podali¶my {\bf IPC\_NOWAIT},
 wiêc wywo³anie natychmiast powróci lub zwróci b³±d je¿eli kto¶ u¿ywa nasz± drukarkê.
Oto przyk³ad u¿ycia zainicjowanej struktury {\tt sembuf}:

\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
        if((semop(sid, &sem_lock, 1) == -1)
                perror("semop");
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}

Trzeci argument ({\tt nsops}) mówi, ¿e wykonujemy tylko jedn± operacjê ( mamy tylko
jedn± strukturê {\tt sembuf} w naszej tablicy ). Argument {\tt sid} jest identyfikatorem
IPC naszego zestawu semaforów.

Po wydrukowaniu musimy {\em oddaæ \/} zasoby z powrotem do zestawu aby inni mogli 
wydrukowaæ swoje prace.


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
        struct sembuf sem_unlock = { 0, 1, IPC_NOWAIT };
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}

Taka struktura dyktuje dodanie 1 do semafora numer 0. Czyli: jedna jednostka zasobu
powraca do zestawu.


\subsubsection{WYWO£ANIE SYSTEMOWE: semctl()}

\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
  WYWO£ANIE SYSTEMOWE: semctl();                                                          
  PROTOTYP: int semctl ( int semid, int semnum, int cmd, union semun arg );
    ZWRACA: liczba dodatnia je¿eli sukces 
             -1 - b³±d: errno = EACCESS ( brak prawa dostêpu )
                                EFAULT ( nieprawid³owy adres wskazywant przez argument arg )
                                EIDRM ( zestaw zosta³ usuniêty )
                                EINVAL ( zestaw nie istnieje lub semid nieprawid³owy )
                                EPERM (EUID nie ma prawa do cmd w arg)
				ERANGE ( warto¶æ semafora przekroczona )
  UWAGI: Przeprowadza operacje kotrolne na zestawie semaforów
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}




Wywo³anie systemowe {\em semctl\/} u¿ywane jest do kontrolowania zestawu semaforów.
Jest ono analogiczne do wywo³ania {\em msgctl\/}, które jest opdowiednie dla kolejek.
Je¿eli porównasz listê argumentów obu wywo³añ zauwa¿ysz, ¿e s± one nieco odmienne.
Przypomnij sobie, i¿ aktualnie semafory s± zaimplementowane jako zestawy, rzadziej ni¿
pojedyñcze jednostki. Do operowania semaforem potrzeba nie tylko klucz IPC, ale
tak¿e numer semafora w zestawie. 

Oba wywo³ania systemowe posiadaj± argument {\em cmd\/} u¿ywany do okre¶lenia operacji.
Ostatni± ró¿nic± jest krañcowy argument. Dla {\em msgctl\/} jest to kopia wewnêtrznej
struktury u¿ywanej przez j±dro. Przypomnij sobie, ¿e u¿ywali¶my j± do odbierania lub
ustawiania informacji o prawa dostêpu i w³a¶cicielu kolejki wiadomo¶ci. Przy semaforach,
dodatkowe komendy operacyjne s± dozwolone co wymaga bardziej z³o¿onej struktury.
U¿ycie {\em union\/} myli wielu pocz±tkuj±cych programistów. W celu zapobie¿enia
temu przeanalizujemy tê strukturê dok³adnie.

Pierwszym argumentem dla {\tt semctl()} jest klucz ( zwrócony przez {\tt semget}). 
Drugi argument ({\tt semun}) to numer semaforu, którym jeste¶my zainteresowani.
Jest to {\em index \/} elementu w zestawie, pierwszy element ma index o warto¶ci 0.

Argument {\tt cmd} przedstawia komendê, która ma zostaæ wykonana. Jak widzisz, mamy
znane komendy IPC\_STAT/IPC\_SET, jak równie¿ wiele dodatkowych specyficznych dla
zestawów semaforów:

\begin{description}
\item[{\bf IPC\_STAT}] \mbox{}
Pobiera strukturê semid\_ds i zachowuje j± w pod adresem buf 
argumentu semun.

\item[{\bf IPC\_SET}] \mbox{}

Ustawia warto¶æ cz³onka ipc\_perm struktury semid\_ds.
Warto¶ci pobiera z buf unii semun.

\item[{\bf IPC\_RMID}] \mbox{}

Usuwa zestaw z j±dra.

\item[{\bf GETALL}] \mbox{}

U¿ywany do pobierania warto¶ci wszystkich semaforów z zestawu
Warto¶ci ca³kowite przechowywane s± w tablicy unsigned short int
wkazywanej przez {\em array\/} - cz³onka unii.

\item[{\bf GETNCNT}] \mbox{}

Zwraca ilo¶æ procesów oczekuj±cych na zasoby.

\item[{\bf GETPID}] \mbox{}

Zwraca PID procesu, który jako ostatni wywo³a³ {\em semop\/}.

\item[{\bf GETVAL}] \mbox{}

Zwaraca warto¶æ pojedyñczego semaforu z zestawu.

\item[{\bf GETZCNT}] \mbox{}

Zwraca ilo¶æ procesów czekaj±cych na 100\% u¿ycia zasobu.

\item[{\bf SETALL}] \mbox{}

Ustawia warto¶ci wszystkich semaforów warto¶ciami z tablicy
{\em array\/} zawartej w unii.

\item[{\bf SETVAL}] \mbox{}

Ustawia warto¶æ jednego semaforu z zestawu. Warto¶æ pobierana
z {\em val\/} zawartego w unii.

\end{description}

Argument {\tt arg} jest elementem typu {\tt semun}. Ta unia
zadeklarowana jest w {\tt linux/sem.h}:

\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
        /* arg dla wywo³ania semctl. */
        union semun {
                int val;                /* warto¶æ dla SETVAL */
                struct semid_ds *buf;   /* bufor dla IPC_STAT i IPC_SET */
                ushort *array;          /* tablica dla GETALL i SETALL */
                struct seminfo *__buf;  /* bufor dla IPC_INFO */
                void *__pad;
        };
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}




\begin{description}
\item[{\tt val}] \mbox{}

U¿ywany gdy komend± jest SETVAL. Okre¶la warto¶æ, któr± nale¿y zapisaæ w semaforze.

\item[{\tt buf}] \mbox{}

U¿ywany dla komend IPC\_STAT/IPC\_SET. Reprezentuje kopiê wewnêtrznej struktury
j±dra u¿ywanej dla semaforów.

\item[{\tt array}] \mbox{}

Wska¼nik u¿ywany dla komend GETALL/SETALL. Powinien wskazywaæ tablicê
warto¶ci ca³kowitych, która zostanie u¿yta do ustawiania lub pobierania
warto¶ci semaforów.

\end{description}
 
Pozosta³e argumenty {\em \_\_buf\/} i {\em \_\_pad\/} s± u¿ywane przez j±dro,
dla programisty nie s± one zbyt u¿yteczne. Gwoli ¶cis³o¶ci s± one specyficzne dla 
Linuksa, nie znajdziesz ich w innych Unixach.

Wywo³anie to jest jednym z najtrudniejszych do zrozumienia wywo³añ IPC Systemu V,
dlatego poka¿emy kilka przyk³adów.

Nastêpuj±ca funkcja zwraca warto¶æ podanego semaforu. Ostatni argument wywo³ania
semctl ( unia ) jest ignorowany dla komendy GETVAL:

\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
int get_sem_val( int sid, int semnum )
{
        return( semctl(sid, semnum, GETVAL, 0));
}
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


Za³u¿my, ¿e potrzebujemy status wszystkich drukarek z naszego przyk³adu:

\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}

        #define MAX_PRINTERS 5

        printer_usage()
        {
                int x;

                for(x=0; x<MAX_PRINTERS; x++)
                        printf("Drukarka %d: %d\n\r", x, get_sem_val( sid, x ));
        }
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}

Rozwa¿ nastepuj±c± funkcjê inicjuj±c± semafor now± warto¶ci±:

\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
void init_semaphore( int sid, int semnum, int initval)
{
        union semun semopts;    

        semopts.val = initval;
        semctl( sid, semnum, SETVAL, semopts);
}
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}

Zauwa¿, i¿ ostatni argument dla {\em semctl\/} jest kopi± unii czê¶ciej ni¿ wska¼nikiem
do niej. Je¿eli ju¿ mówimy o przekazywaniu unii jako argument powolê sobie przedstawiæ
czêste b³êdy podczas u¿ywania tego wywo³ania.

W projekcie msgtool komendy IPC\_STAT i IPC\_SET by³y u¿ywane do ustawiania/pobierania
praw dostêpu do kolejki. S± one równie¿ zaimplementowane dla semaforów, jednak ich
sposób u¿ycia jest nieco odmienny dlatego, i¿ wewnêtrzna struktura jest odbierana i kopiowana z unii,
rzadziej ni¿ z pojedyñczej jednostki. Czy potrafisz zlokalizowaæ b³±d w nastêpuj±cym kodzie ?


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}

/* ¯±dane prawa dostêpu powinny byæ przekazane jako tekst ( np.: "660" ) */

void changemode(int sid, char *mode)
{
        int rc;
        struct semid_ds mysemds;

        /* pobierz warto¶ci wewnêtrznej struktury danych */
        if((rc = semctl(sid, 0, IPC_STAT, semopts)) == -1)
        {
                perror("semctl");
                exit(1);
        }
                
        printf("Stare prawa dostêpu: %o\n", semopts.buf->sem_perm.mode);
                
        /* zmiana restrykcji dla semaforu*/
        sscanf(mode, "%o", &semopts.buf->sem_perm.mode);

        /* aktualizacja wewnêtrznej struktury danych */
        semctl(sid, 0, IPC_SET, semopts);

        printf("Zaktualizowano...\n");
}
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}

Kod próbuje stworzyæ lokaln± kopiê wewnêtrznej struktury dla zestawu,
zmodyfikowaæ prawa dostêpu i ustawiæ je ( dziêki IPC\_SET ) w j±drze.
Niestety, pierwsze wywo³anie {\em semctl\/} zwraca EFAULT lub z³y adres do ostatniego
argumentu ( unii! ). Dodatkowo, je¿eli nie sprawdzili¶my b³êdów dla tego wywo³ania
mo¿emy dostaæ b³±d pamiêci. Dlaczego?

Przypomnij sobie, i¿ komendy IPC\_SET/IPC\_STAT u¿ywaj± element unii - {\em buf\/}, jest
on {\em wska¼nikiem\/} do zmiennej typu {\em semid\_ds\/}. Wska¼niki s± wska¼nikami,
s± wska¼nikami, s± wska¼nikami! Element {\em buf\/} musi wskazywaæ jak±¶
prawid³ow± lokalizacjê aby funkcja dzia³a³a prawid³owo. Oto zmieniona
wersja:

\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}

void changemode(int sid, char *mode)
{
        int rc;
        struct semid_ds mysemds;

        /* pobierz warto¶ci wewnêtrznej struktury danych */

        /* wka¿ nasz± lokaln± kopiê! */
        semopts.buf = &mysemds;

        /* spróbujmy ponownie! */
        if((rc = semctl(sid, 0, IPC_STAT, semopts)) == -1)
        {
                perror("semctl");
                exit(1);
        }
                
        printf("Stare prawa dostêpu: %o\n", semopts.buf->sem_perm.mode);
                
        /* zmiana restrykcji dla semaforu */
        sscanf(mode, "%o", &semopts.buf->sem_perm.mode);

        /* aktualizacja wewnêtrznej struktury danych */
        semctl(sid, 0, IPC_SET, semopts);

        printf("Zaktualizowano...\n");
}
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}

\subsubsection{semtool: interaktywny manipulator semaforów}

\paragraph{Wstêp}

Program {\tt semtool} opiera swój sposób dzia³ania na podanych argumentach. To czyni
go wyj±tkowo u¿ytecznym w skryptach. Wszelkie mo¿liwo¶ci s± dostarczone: tworzenie,
manipulowanie, zmiana praw dostêpu, usuwanie zestawu semaforów. Mo¿e zostaæ
u¿yty do kontrolowania dzielonych zasobów za pomoc± skryptów pow³oki.

\paragraph{Sk³adnia wywo³ania}




\subparagraph{Tworzenie zestawu semaforów}

\begin{verbatim}
semtool s ( licza semaforów w zestawie )
\end{verbatim}

\subparagraph{Blokowanie semaforu}

\begin{verbatim}
semtool z ( numer semaforu do zablokowania )
\end{verbatim}

\subparagraph{Odblokowywanie semaforu}

\begin{verbatim}
semtool o ( numer semaforu do odblokowania )
\end{verbatim}

\subparagraph{Zmiana praw dostêpu ( trybu )}

\begin{verbatim}
semtool t ( tryb )
\end{verbatim}

\subparagraph{Usuwanie zestawu semaforów}

\begin{verbatim}
semtool u 
\end{verbatim}

\paragraph{Przyk³ady}

\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
semtool  s 5
semtool  z
semtool  o
semtool  t 660
semtool  u
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


\paragraph{¬ród³o}

\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}

/*****************************************************************************
 Zaczerpniêto z "Linux Programmer's Guide - Rozdzia³ 6"
 (C)opyright 1994-1995, Scott Burkett
 ***************************************************************************** 
 MODU£: semtool.c
 *****************************************************************************
 Narzêdzie zarz±dzaj±ce semaforami stylu SysV z linii poleceñ
 *****************************************************************************/

#include <stdio.h>
#include <ctype.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/sem.h>

/* U mnie ( RedHat6.0, j±dro 2.2.12-20 )
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/sem.h>	*/


#define SEM_RESOURCE_MAX        1       /* warto¶æ inicjuj±ca wszystkie semafory */

void opensem(int *sid, key_t key);
void createsem(int *sid, key_t key, int members);
void locksem(int sid, int member);
void unlocksem(int sid, int member);
void removesem(int sid);
unsigned short get_member_count(int sid);
int getval(int sid, int member);
void dispval(int sid, int member);
void changemode(int sid, char *mode);
void usage(void);

int main(int argc, char *argv[])
{
        key_t key;
        int   semset_id;

        if(argc == 1)
                usage();

        /* tworzymy unikalny klucz za pomoc± wywo³ania ftok() */
        key = ftok(".", 's');

        switch(tolower(argv[1][0]))
        {
                case 's': if(argc != 3)
                                usage();
                          createsem(&semset_id, key,  atoi(argv[2]));
                          break;
                case 'z': if(argc != 3)
                                usage();
                          opensem(&semset_id, key);
                          locksem(semset_id, atoi(argv[2]));
                          break;
                case 'o': if(argc != 3)
                                usage();
                          opensem(&semset_id, key);
                          unlocksem(semset_id, atoi(argv[2]));
                          break;
                case 'u': opensem(&semset_id, key);
                          removesem(semset_id);
                          break;        
                case 't': opensem(&semset_id, key);
                          changemode(semset_id, argv[2]);
                          break;        
                 default: usage();

        }
        
        return(0);
}

void opensem(int *sid, key_t key)
{
        /* otwórz zestaw semaforów, nie twórz go! */

        if((*sid = semget(key, 0, 0666)) == -1) 
        {
                printf("Zestaw semaforów nie istnieje!\n");
                exit(1);
        }

}

void createsem(int *sid, key_t key, int members)
{
        int cntr;
        union semun semopts;

        if(members > SEMMSL) {
                printf("Przykro mi, maxymaln± liczb± semaforów w zestawie jest %d\n",
                        SEMMSL);
                exit(1);
        }

        printf("Próbujê utworzyæ nowy zestaw semaforów z %d elementami\n",
                                members);

        if((*sid = semget(key, members, IPC_CREAT|IPC_EXCL|0666))
                        == -1) 
        {
                fprintf(stderr, "Zestaw semaforów istnieje!\n");
                exit(1);
        }

        semopts.val = SEM_RESOURCE_MAX;
        
        /* Inicjalizacja wszystkich cz³onków ( mo¿na to zrobiæ za pomoc± SETALL ) */
        for(cntr=0; cntr<members; cntr++)
                semctl(*sid, cntr, SETVAL, semopts);
}

void locksem(int sid, int member)
{
        struct sembuf sem_lock={ 0, -1, IPC_NOWAIT};

        if( member<0 || member>(get_member_count(sid)-1))
        {
                fprintf(stderr, "%d - cz³onek semaforu poza zasiêgiem\n", member);
                return;
        }

        /* Próba zablokowania zestawu semaforów */
        if(!getval(sid, member))
        {
                fprintf(stderr, "Zasoby semaforu wyczerpane ( brak blokady )!\n");
                exit(1);
        }
        
        sem_lock.sem_num = member;
        
        if((semop(sid, &sem_lock, 1)) == -1)
        {
                fprintf(stderr, "Blokowanie nie powiod³o siê\n");
                exit(1);
        }
        else
                printf("Zasoby semaforu zmiejszone o jeden ( zablokowane )\n");

        dispval(sid, member);
}

void unlocksem(int sid, int member)
{
        struct sembuf sem_unlock={ member, 1, IPC_NOWAIT};
        int semval;

        if( member<0 || member>(get_member_count(sid)-1))
        {
                fprintf(stderr, "%d - cz³onek semaforu poza zasiêgiem\n", member);
                return;
        }

        /* Czy semafor jest zablokowany? */
        semval = getval(sid, member);
        if(semval == SEM_RESOURCE_MAX) {
                fprintf(stderr, "Semafor nie jest zablokowany!\n");
                exit(1);
        }

        sem_unlock.sem_num = member;

        /* Próba odblokowania semaforu */
        if((semop(sid, &sem_unlock, 1)) == -1)
        {
                fprintf(stderr, "Odblokowywanie nie powiod³o siê\n");
                exit(1);
        }
        else
                printf("Zasoby semaforu zwiêkszone o jeden ( odblokowane )\n");

        dispval(sid, member);
}

void removesem(int sid)
{
        semctl(sid, 0, IPC_RMID, 0);
        printf("Usuniêto zestaw semaforów\n");
}

unsigned short get_member_count(int sid)
{
        union semun semopts;
        struct semid_ds mysemds;

        semopts.buf = &mysemds;
	
	semctl(sid, 0, IPC_STAT, semopts);
        
	/* zwraca liczbê cz³onków zestawu semaforów */
        return(semopts.buf->sem_nsems);
}

int getval(int sid, int member)
{
        int semval;

        semval = semctl(sid, member, GETVAL, 0);
        return(semval);
}

void changemode(int sid, char *mode)
{
        int rc;
        union semun semopts;
        struct semid_ds mysemds;

        /* pobierz aktaln± warto¶æ wewnêtrznej struktury */
        semopts.buf = &mysemds;

        rc = semctl(sid, 0, IPC_STAT, semopts);

        if (rc == -1) {
                perror("semctl");
                exit(1);
        }
                
        printf("Stare prawa dostêpu: %o\n", semopts.buf->sem_perm.mode);
                
        /* Zmieñ prawa dostêpu do zestawu semaforów */
        sscanf(mode, "%ho", &semopts.buf->sem_perm.mode);

        /* Zaktualizuj wewnêtrzn± strukturê danych */
        semctl(sid, 0, IPC_SET, semopts);

        printf("Zaktualizowano...\n");

}

void dispval(int sid, int member)
{
        int semval;

        semval = semctl(sid, member, GETVAL, 0);
        printf("semval elementu %d to %d\n", member, semval);
}

void usage(void)
{
        fprintf(stderr, "semtool - narzêdzie do majstrowania przy semaforach\n");
        fprintf(stderr, "\nU¯YCIE:  semtool (s)twórz <ilo¶æ semaforów>\n");
        fprintf(stderr, "                 (z)ablokuj <nr sem.>\n");
        fprintf(stderr, "                 (o)dblokuj <nr sem.>\n");
        fprintf(stderr, "                 (u)suñ\n");
        fprintf(stderr, "                 (t)ryb <tryb>\n");
        exit(1);
}
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}

\subsubsection{semstat: kompan programu semtool}
Jako dodatek: kod ¼ród³owy programu {\tt semstat}. Jest to program wy¶wietlaj±cy
warto¶ci ka¿dego semaforu z zestawu utworzonego za pomoc± {\tt semtool}.

\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}

/*****************************************************************************
 Zaczerpniêto z "Linux Programmer's Guide - Rozdzia³ 6"
 (C)opyright 1994-1995, Scott Burkett
 ***************************************************************************** 
 MODU£: semstat.c
 *****************************************************************************
 Program towarzysz±cy semtool. semstat wy¶wietla warto¶ci semaforów z zestawu
 utworzonego przez semtool.
 *****************************************************************************/

#include <stdio.h>
#include <stdlib.h>

#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/sem.h>

/* U mnie ( RedHat6.0, j±dro 2.2.12-20 )
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/sem.h>    */


int get_sem_count(int sid);
void show_sem_usage(int sid);
int get_sem_count(int sid);
void dispval(int sid);

int main(int argc, char *argv[])
{
        key_t key;
        int   semset_id;

        /* tworzymy unikalny klucz za pomoc± wywo³ania ftok() */
        key = ftok(".", 's');

        /* otwieramy zestaw semaforów - nie tworzymy! */
        if((semset_id = semget(key, 1, 0666)) == -1) 
        {
                printf("Zestaw semaforów nie istnieje\n");
                exit(1);
        }

        show_sem_usage(semset_id); 
        return(0);
}

void show_sem_usage(int sid)
{
        int cntr=0, maxsems, semval;

        maxsems = get_sem_count(sid);

        while(cntr < maxsems) {
                semval = semctl(sid, cntr, GETVAL, 0);
                printf("Semafor #%d:  --> %d\n", cntr, semval);
                cntr++;
        }
}

int get_sem_count(int sid)
{
        int rc;
        struct semid_ds mysemds;
        union semun semopts;

        /* pobierz warto¶ci wewnêtrznej struktury danych */
        semopts.buf = &mysemds;

        if((rc = semctl(sid, 0, IPC_STAT, semopts)) == -1) {
                perror("semctl");
                exit(1);
        }

        /* zwróæ liczbê semaforów w zestawie */
        return(semopts.buf->sem_nsems);
}

void dispval(int sid)
{
        int semval;

        semval = semctl(sid, 0, GETVAL, 0);
        printf("semval = %d\n", semval);
}
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}



\subsection{Pamiêæ dzielona}


\subsubsection{Podstawy}

Pamiêæ dzielon± mo¿na najlepiej opisaæ jako obszar pamiêci ( segment ), który bêdzie
dzielony miêdzy kilkoma procesami. Jest to najszybsza forma IPC, poniewa¿ nie istnieje
¿aden po¶rednik ( potok, kolejka wiadomo¶ci ). Zamiast tego informacja
jest bezpo¶redno umieszczana w segmencie pamiêci, w obszarze adresowym procesu wywo³uj±cego.
Segment mo¿e zostaæ utworzony przez jeden proces, a wykorzystywaæ go mo¿e
dowolna liczba procesów.


\subsubsection{Struktury danych: wewnêtrzne i u¿ytkownika}

Przyj¿yjmy siê strukturom danych, które j±dro utrzymuje dla pamiêci dzielonej.

\paragraph{Struktura {\tt shmid\_ds} w j±drze}

Tak jak w przypadku kolejek wiadomo¶ci i zestawów semaforów, j±dro przechowuje
specjaln± wewnêtrzn± strukturê dla ka¿dego segmentu pamiêci dzielonej.
Struktura ta jest typu {\tt shmid\_ds}, który zdefiniowany jest w {\tt linux/shm.h}:

\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
        /* jedna struktura shmid dla ka¿dego segmentu pamiêci dzielonej w systemie. */
        struct shmid_ds {
                struct ipc_perm shm_perm;        /* prawa dostêpu */
                int     shm_segsz;               /* rozmiar segmentu ( bajty ) */
                time_t  shm_atime;               /* czas ostatniego pod³±czenia */
                time_t  shm_dtime;               /* czas ostatniego od³±czenia */
                time_t  shm_ctime;               /* czas ostatniej zmiany */
                unsigned short  shm_cpid;        /* pid twórcy */
                unsigned short  shm_lpid;        /* pid ostatniego operatora */
                short   shm_nattch;              /* ilo¶æ aktualnych pod³±czeñ */

                                                 /* nastêpuj±ce s± prywatne: */

                unsigned short   shm_npages;     /* rozmiar segmentu ( strony ) */
                unsigned long   *shm_pages;      /* tablica wska¼ników do ramek -> SHMMAX */ 
                struct vm_area_struct *attaches; /* deskryptory pod³±czeñ */
        };
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}

Operacje na tej strukturze wykonywane s± przez specjalne wywo³anie systemowe,
nie powiniene¶ jej zmieniaæ inn± metod±. Oto opis wa¿niejszych pól:

\begin{description}
\item[{\tt shm\_perm}] \mbox{}

Jest to struktura {\tt ipc\_perm}, jest ona zdefiniowana w {\tt linux/ipc.h}.
Przechowuje ona informacje na temat praw dostêpu, twórcy ( uid, itd. ).

\item[{\tt shm\_segsz}] \mbox{}

Rozmiar segmentu ( w bajtach ).

\item[{\tt shm\_atime}] \mbox{}

Czas ostatniego podpiêcia segmentu.

\item[{\tt shm\_dtime}] \mbox{}

Czas ostatniego odpiêcia segmentu.

\item[{\tt shm\_ctime}] \mbox{}

Czas ostatniej zmiany tej struktury ( zmiana trybu, itp. ).

\item[{\tt shm\_cpid}] \mbox{}

PID procesu tworz±cego.

\item[{\tt shm\_lpid}] \mbox{}

PID procesu, który jako ostatni operowa³ na segmencie.

\item[{\tt shm\_nattch}] \mbox{}

Liczba procesów podpiêtych do segmentu.

\end{description}


\subsubsection{WYWO£ANIE SYSTEMOWE: shmget()}

W celu utworzenia nowego ( lub otworzenia ) segmentu pamiêci u¿ywamy 
wywo³ania systemowego {\tt shmget()}:

\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
  WYWO£ANIE SYSTEMOWE: shmget();                                                          

  PROTOTYP: int shmget ( key_t key, int size, int shmflg );                                             
    ZWRACA: identyfikator pamiêci dzielonej, je¿eli sukces
            -1 - b³±d: errno = EINVAL ( nieprawid³owy rozmiar segmentu )
			       EEXIST ( segment istnieje, nie mo¿na utworzyæ )
                               EIDRM ( segment czeka na usuniêcie, lub usuniêty )
                               ENOENT ( segment nie isnieje )
                               EACCES ( brak prawa dostêpu )
                               ENOMEM ( brak pamiêci do utworzenia segmentu )
  UWAGI: 
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}

Pewnie przypomina ci to poprzednie wywo³ania z cyklu {\tt get}.

Pierwszym argumentem jest klucz ( w naszym wypadku zwrócony przez {\tt ftok()} ).
Warto¶æ ta porównywana jest do innych kluczy segmentów pamiêci. Teraz akcja
zale¿y od zawarto¶ci argumentu {\tt shmflg}:

\begin{description}
\item[IPC\_CREAT] \mbox{}

Utwórz segment je¿eli ten nie istnieje.

\item[IPC\_EXCL] \mbox{}

U¿yte z IPC\_CREAT zwraca b³±d je¿eli segment ju¿ istnieje.

\end{description}

Je¿eli podano tylko {\tt IPC\_CREAT} {\tt shmget()} zwraca identyfikator
segmentu istniej±cego lub utworzonego. W po³±czeniu z {\tt IPC\_EXCL}
tworzony jest nowy segment lub wywo³anie zwraca b³±d. Gwarantuje nam to, i¿
to my tworzymy segment pamiêci.

I tym razem mo¿esz równie¿ z'OR'owaæ z mask± ósemkowy tryb.

Utwórzmy szkielet funkcji tworz±cej segment pamiêci:

\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
int open_segment( key_t keyval, int segsize )
{
        int     shmid;
        
        if((shmid = shmget( keyval, segsize, IPC_CREAT | 0660 )) == -1)
        {
                return(-1);
        }
        
        return(shmid);
}
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}

Zauwa¿, i¿ ustawiamy prawa dostêpu na {\tt 0660}. Ta prosta funkcja
zwraca indentyfikator segmentu pamiêci dzielonej lub -1. Klucz oraz rozmiar
segmentu przekazywane s± jako argumenty.

Nastêpnym krokiem po otrzymaniu identyfikatora segmentu jest {\tt pod³±czenie}
lub mapowanie segmentu w obszar adresowy.

\subsubsection{WYWO£ANIE SYSTEMOWE: shmat()}



\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
  WYWO£ANIE SYSTEMOWE: shmat();                                                          

  PROTOTYP: int shmat ( int shmid, char *shmaddr, int shmflg);
    ZWRACA: adres pod którym segment zosta³ przy³±czony do procesu
	    -1 - b³±d: errno = EINVAL ( nieprawid³owy ID IPC lub podano adress pod³±czenia )
                               ENOMEM ( brak pamiêci aby przy³±czyæ segment )
                               EACCES ( brak pozwolenia )
  UWAGI: 
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}

Je¿eli argument addr = 0 j±dro próbuje znale¼æ niemapowany region. Jest to
zalecany sposób u¿ycia. Jednak¿e mo¿na równie¿ podaæ adres, jest to u¿ywane
aby u³atwiæ dostêp do sprzêtu, lub rozwi±zaæ konflikty z innymi programami.
Flaga SHM\_RND mo¿e byæ z'OR'owana z argumentem shmflg aby wymusiæ stronicowe
wyrównanie adresu ( zaokr±glenie w dó³ do najbli¿szego rozmiaru strony ).

Dodatkowo, je¿eli podano flagê SHM\_RDONLY segment zostanie wmapowany 
jako "tylko do oczytu".

Jest to chyba naj³atwiejsze wywo³anie. Rozwa¿ przyk³adow± funkcjê, której
podajemy identyfikator segmentu, a ona zwraca adres pod którym segment zosta³
pod³±czony:

\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}

char *attach_segment( int shmid )
{
        return(shmat(shmid, 0, 0));
}
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}

Po poprawnym przy³±czeniu segmentu otrzymujemy wska¼nik do pocz±tku segmentu,
u¿ycie segmentu jest po prostu u¿yciem wska¼nika. Pamiêtaj aby zachowaæ warto¶æ
pocz±tkow± wska¼nika! Je¿eli tego nie zrobisz nie bêdziesz mia³ dostêpu
do pocz±tku segmentu.


\subsubsection{WYWO£ANIE SYSTEMOWE: shmctl()}


\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
  WYWO£ANIE SYSTEMOWE: shmctl();
  PROTOTYP: int shmctl ( int shmqid, int cmd, struct shmid_ds *buf );
    ZWRACA: 0 - sukces
            -1 - b³±d: errno = EACCES ( odczyt zabroniony i cmd jest ustawiony na IPC_STAT )
                               EFAULT ( adres wskazywany przez buf jest nieprawid³owy dla
			                komend IPC_SET i IPC_STAT )
                               EIDRM  ( segment zosta³ usuniêty )
                               EINVAL ( nieprawid³owy shmqid )
                               EPERM  ( podano komendy IPC_SET lub IPC_RMID, jednak
			                proces nie ma prawa zapisu, lub dostêpu do segmentu )
      UWAGI:
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}

Wywo³anie to jest utworzone na podobieñstwo {\em msgctl\/}, wiêc nie bêdê siê
nad nim rozwodzi³. Prawid³owe komendy to:

\begin{description}
\item[{\bf IPC\_STAT}] \mbox{}

Pobiera strukturê shmid\_ds i zachowuje j± pod 
adresem wskazywanym przez buf.

\item[{\bf IPC\_SET}] \mbox{}

Ustawia warto¶æ elementu ipc\_perm struktury 
shmid\_ds. Pobiera warto¶æ z argumentu buf.

\item[{\bf IPC\_RMID}] \mbox{}

Zaznacza segment do usuniêcia.

\end{description}

Aktualnie komenda IPC\_RMID nie usuwa segmentu. {\tt Zaznacza} segment do usuniêcia, które
nastêpuje po od³±czeniu segmentu przez ostatni proces. Oczywi¶cie, je¿eli ¿aden
proces nie u¿ywa segmentu zostaje on natychmiast usuniêty.

Aby od³±czyæ segment pamiêci dzielonej proces wywo³uje {\em shmdt\/}.

\subsubsection{WYWO£ANIE SYSTEMOWE: shmdt()}

\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
  WYWO£ANIE SYSTEMOWE: shmdt();                                                          

  PROTOTYP: int shmdt ( char *shmaddr );
    ZWRACA: -1 - b³±d: errno = EINVAL ( podano nieprawid³owy adres pod³±czenia )
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}

Gdy segment nie jest ju¿ potrzebny przez proces powinno nast±piæ od³±czenie.
Jak wspomniano wcze¶niej nie jest to równoznaczne z usuniêciem segmentu z j±dra.
Pod od³±czeniu element shm\_nattch struktury shmid\_ds jest dekrementowany.
Je¿eli jego warto¶æ osi±gnie 0 segment zostanie fizycznie usuniêty przez j±dro.


\subsubsection{shmtool: interaktywny manipulator segmentem pamiêci dzielonej}

\paragraph{Wstêp}

Naszym ostatnim przyk³adem IPC Systemu V bêdzie {\tt shmtool}, który jest
programem tworz±cym, czytaj±cym oraz usuwaj±cym segment pamiêci dzielonej.
Tak jak w poprzednich przyk³adach je¿eli segment nie istnieje zostanie utworzony
podczas dowolnej operacji.

\paragraph{Sk³adnia wywo³ania}


\subparagraph{Zapisywanie ³añcuchów do segmentu}

\begin{verbatim}
shmtool z "text"
\end{verbatim}

\subparagraph{Odbieranie ³añcuchów z segmentu}

\begin{verbatim}
shmtool o 
\end{verbatim}

\subparagraph{Zmiana praw dostêpu ( trybu )}

\begin{verbatim}
shmtool t ( tryb )
\end{verbatim}

\subparagraph{Usuwanie segmentu}

\begin{verbatim}
shmtool u 
\end{verbatim}

\paragraph{Przyk³ady}

\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
shmtool  z   test
shmtool  z   "Pozdrowienia z Afryki...Sta¶ i Nel"
shmtool  o   
shmtool  u
shmtool  t   660
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}

\paragraph{¬ród³o}

\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
#include <stdio.h>
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/shm.h>

#define SEGSIZE 100

main(int argc, char *argv[])
{
        key_t key;
        int   shmid, cntr;
        char  *segptr;

        if(argc == 1)
                usage();

        /* utwórz unikalny klucz poprzez wywo³anie ftok() */
        key = ftok(".", 'S');

        /* otwórz segment pamiêci dzielonej - utwórz je¿eli trzeba */
        if((shmid = shmget(key, SEGSIZE, IPC_CREAT|IPC_EXCL|0666)) == -1) 
        {
                printf("Segment pamiêci dzielonej istnieje - otwieram jako klient");

                /* Segment prawdopodobnie istnieje - próbujê otworzyæ jako klient */
                if((shmid = shmget(key, SEGSIZE, 0)) == -1) 
                {
                        perror("shmget");
                        exit(1);
                }
        }
        else
        {
                printf("Tworzenie nowego segmentu pamiêci dzielonej\n");
        }

        /* Pod³±cz ( mapuj ) segment pamiêci dzielonej do tego procesu */
        if((segptr = shmat(shmid, 0, 0)) == -1)
        {
                perror("shmat");
                exit(1);
        }
        
        switch(tolower(argv[1][0]))
        {
                case 'z': writeshm(shmid, segptr, argv[2]);
                          break;
                case 'o': readshm(shmid, segptr);
                          break;
                case 'u': removeshm(shmid);
                          break;
                case 't': changemode(shmid, argv[2]);
                          break;
                 default: usage();

        }
}

writeshm(int shmid, char *segptr, char *text)
{
        strcpy(segptr, text);
        printf("Zrobiono...\n");
}

readshm(int shmid, char *segptr)
{
        printf("segptr: %s\n", segptr);
}

removeshm(int shmid)
{
        shmctl(shmid, IPC_RMID, 0);
        printf("Segment pamiêci dzielonej ustawiony do usuniêcia\n");
}

changemode(int shmid, char *mode) 
{
        struct shmid_ds myshmds;

        /* pobierz aktualne warto¶ci wewnêtrznej struktury danych */
        shmctl(shmid, IPC_STAT, &myshmds);

        /* wy¶wietl stare prawa dostêpu */
        printf("Stare prawa dostêpu: %o\n", myshmds.shm_perm.mode);

        /* konwertuj i za³aduj prawa dostêpu */ 
        sscanf(mode, "%o", &myshmds.shm_perm.mode);

        /* aktualizuj tryb */
        shmctl(shmid, IPC_SET, &myshmds);

        printf("Nowe prawa dostêpu : %o\n", myshmds.shm_perm.mode);
}

usage()
{
        fprintf(stderr, "shmtool - narzêdzie do majstrowania segmentem pamiêci dzielonej\n");
        fprintf(stderr, "\nU¯YCIE:  shmtool (z)apisz <text>\n");
        fprintf(stderr, "                 (o)dczytaj\n");
        fprintf(stderr, "                 (u)suñ\n");
        fprintf(stderr, "                 (t)ryb <tryb ósemkowo>\n");
        exit(1);
}
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


\endinput
