\author {Sven Goldt}
\title{Wywo³ania systemowe}
% \chapter {Wywo³ania systemowe}

 Wywo³anie systemowe jest zazwyczaj pro¶b± do systemu operacyjnego (j±dra) aby
 zosta³a wykonana operacja zale¿na od sprzêtu/systemu lub uprzywilejowana.  
 Dla Linuxa 1.2 zadeklarowanych zosta³o 140 wywo³añ systemowych. Wywo³ania takie jak
 close() zaimplementowane s± w libc Linuxa. Taka implementacja czêsto
 wymaga wywo³ania makra, które odwo³uje siê do syscall().  Parametry
 przekazywane do syscall() to numer wywo³ania oraz potrzebne 
 argumenty.  Aktualne numery wywo³ania mo¿na znale¼æ w
 $<linux/unistd.h>$ podczas gdy $<sys/syscall.h>$ jest aktualizowany wraz z now±
 libc.  Je¿eli pojawiaj± siê nowe wywo³ania systemowe, które nie s± zosta³y jeszcze zawarte w libc, 
 mo¿esz u¿yæ syscall().  Dla przyk³adu: aby zamkn±æ plik mo¿na u¿yæ syscall()
 w ten sposób (nie zalecane):

\begin{verbatim}
#include <syscall.h>

extern int syscall(int, ...);

int my_close(int filedescriptor)
{
   return syscall(SYS_close, deskryptor_pliku);
}
\end{verbatim}

 Na platformie i386 wywo³ania systemowe maj± ograniczon± do 5, oprócz
 numeru wywo³ania, liczbê argumentów - ze wzglêdu na liczbê
 rejestrów sprzêtowych.  Je¿eli u¿ywasz Linuxa na innej platformie sprawd¼
 w $<asm/unistd.h>$  makro \_syscall aby poznaæ ile argumentów
 wspomaga twój sprzêt lub ile zosta³o zdefiniowanych do u¿ycia przez twórców.
 Makra \_syscall mog± byæ u¿ywane zamiast syscall(), jednak¿e nie jest to 
 zalecane poniewa¿ takie makro zostanie rozwiniête do funkcji która
 mo¿e ju¿ byæ zdefiniowana w bibliotece. Dlatego tylko specjali¶ci (kernel hackers)
 powinni bawiæ siê z makrami \_syscall.  Dla przyk³adu: oto
 close() w postaci makra \_syscall.

\begin{verbatim}
#include <linux/unistd.h>

_syscall1(int, close, int, deskryptor_pliku);
\end{verbatim}
 
 Makro \_syscall1 rozwija siê do postaci funkcji close(). Tak wiêc mamy
 close() podwójnie - raz w libc i raz w naszym programie.  
 Syscall() lub makro \_syscall zwracaj± -1 je¿eli wywo³anie nie powiod³o siê
 oraz 0 lub wiêcej je¿eli uda³o siê.  Je¿eli chcesz wiedzieæ co dok³adnie
 zawiod³o sprawd¼ warto¶æ zmiennej errno.

 Nastêpuj±ce wywo³ania, które s± zdefiniowane w BSD lub SYS V s± niedostêpne w Linuksie: 
 \\ audit(), auditon(), auditsvc(), fchroot(),
 getauid(), getdents(), getmsg(), mincore(), poll(), putmsg(),
 setaudit(), setauid().

\endinput
